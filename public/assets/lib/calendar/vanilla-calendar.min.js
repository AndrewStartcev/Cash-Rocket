/*! name: vanilla-calendar-pro v2.9.9 | url: https://github.com/uvarov-frontend/vanilla-calendar-pro */
!function (e, t) { "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).VanillaCalendar = t() }(this, (function () { "use strict"; var e = Object.defineProperty, t = Object.getOwnPropertySymbols, n = Object.prototype.hasOwnProperty, a = Object.prototype.propertyIsEnumerable, s = (t, n, a) => n in t ? e(t, n, { enumerable: !0, configurable: !0, writable: !0, value: a }) : t[n] = a, l = (e, l) => { for (var i in l || (l = {})) n.call(l, i) && s(e, i, l[i]); if (t) for (var i of t(l)) a.call(l, i) && s(e, i, l[i]); return e }, i = (e, t, n) => (s(e, "symbol" != typeof t ? t + "" : t, n), n); const r = { calendar: "vanilla-calendar", calendarDefault: "vanilla-calendar_default", calendarMultiple: "vanilla-calendar_multiple", calendarMonth: "vanilla-calendar_month", calendarYear: "vanilla-calendar_year", calendarHidden: "vanilla-calendar_hidden", calendarToInput: "vanilla-calendar_to-input", calendarToInputTop: "vanilla-calendar_to-input_top", calendarToInputBottom: "vanilla-calendar_to-input_bottom", controls: "vanilla-calendar-controls", grid: "vanilla-calendar-grid", gridDisabled: "vanilla-calendar-grid_disabled", column: "vanilla-calendar-column", columnMonth: "vanilla-calendar-column_month", columnYear: "vanilla-calendar-column_year", header: "vanilla-calendar-header", headerContent: "vanilla-calendar-header__content", month: "vanilla-calendar-month", monthDisabled: "vanilla-calendar-month_disabled", year: "vanilla-calendar-year", yearDisabled: "vanilla-calendar-year_disabled", arrow: "vanilla-calendar-arrow", arrowPrev: "vanilla-calendar-arrow_prev", arrowNext: "vanilla-calendar-arrow_next", wrapper: "vanilla-calendar-wrapper", content: "vanilla-calendar-content", week: "vanilla-calendar-week", weekDay: "vanilla-calendar-week__day", weekDayWeekend: "vanilla-calendar-week__day_weekend", days: "vanilla-calendar-days", daysSelecting: "vanilla-calendar-days_selecting", months: "vanilla-calendar-months", monthsSelecting: "vanilla-calendar-months_selecting", monthsMonth: "vanilla-calendar-months__month", monthsMonthSelected: "vanilla-calendar-months__month_selected", monthsMonthDisabled: "vanilla-calendar-months__month_disabled", years: "vanilla-calendar-years", yearsSelecting: "vanilla-calendar-years_selecting", yearsYear: "vanilla-calendar-years__year", yearsYearSelected: "vanilla-calendar-years__year_selected", yearsYearDisabled: "vanilla-calendar-years__year_disabled", time: "vanilla-calendar-time", timeContent: "vanilla-calendar-time__content", timeHours: "vanilla-calendar-time__hours", timeMinutes: "vanilla-calendar-time__minutes", timeKeeping: "vanilla-calendar-time__keeping", timeRanges: "vanilla-calendar-time__ranges", timeRange: "vanilla-calendar-time__range", day: "vanilla-calendar-day", dayHoverFirst: "vanilla-calendar-day_hover-first", dayHoverLast: "vanilla-calendar-day_hover-last", dayHoverIntermediate: "vanilla-calendar-day_hover-intermediate", daySelectedFirst: "vanilla-calendar-day_selected-first", daySelectedLast: "vanilla-calendar-day_selected-last", daySelectedIntermediate: "vanilla-calendar-day_selected-intermediate", dayPopup: "vanilla-calendar-day__popup", dayBtn: "vanilla-calendar-day__btn", dayBtnPrev: "vanilla-calendar-day__btn_prev", dayBtnNext: "vanilla-calendar-day__btn_next", dayBtnToday: "vanilla-calendar-day__btn_today", dayBtnSelected: "vanilla-calendar-day__btn_selected", dayBtnHover: "vanilla-calendar-day__btn_hover", dayBtnDisabled: "vanilla-calendar-day__btn_disabled", dayBtnWeekend: "vanilla-calendar-day__btn_weekend", dayBtnHoliday: "vanilla-calendar-day__btn_holiday", weekNumbers: "vanilla-calendar-week-numbers", weekNumbersTitle: "vanilla-calendar-week-numbers__title", weekNumbersContent: "vanilla-calendar-week-numbers__content", weekNumber: "vanilla-calendar-week-number", isFocus: "vanilla-calendar-is-focus" }, d = e => `<div class="${e.controls}"><#ArrowPrev /><#ArrowNext /></div><div class="${e.grid}"><#Multiple><div class="${e.column}"><div class="${e.header}"><div class="${e.headerContent}"><#Month /><#Year /></div></div><div class="${e.wrapper}"><#WeekNumbers /><div class="${e.content}"><#Week /><#Days /></div></div></div><#/Multiple></div><#ControlTime />`, o = e => `<div class="${e.header}"><div class="${e.headerContent}"><#Month /><#Year /></div></div><div class="${e.wrapper}"><div class="${e.content}"><#Months /></div></div>`, c = e => `<div class="${e.header}"><#ArrowPrev /><div class="${e.headerContent}"><#Month /><#Year /></div><#ArrowNext /></div><div class="${e.wrapper}"><div class="${e.content}"><#Years /></div></div>`; class u { constructor() { var e; i(this, "isInit", !1), i(this, "isInputInit", !1), i(this, "input", !1), i(this, "type", "default"), i(this, "months", 2), i(this, "jumpMonths", 1), i(this, "jumpToSelectedDate", !1), i(this, "toggleSelected", !0), i(this, "date", { min: "1970-01-01", max: "2470-12-31", today: new Date }), i(this, "settings", { lang: "en", iso8601: !0, range: { min: void 0, max: void 0, disablePast: !1, disableGaps: !1, edgesOnly: !1, disableAllDays: !1, disableWeekday: void 0, disabled: void 0, enabled: void 0 }, selection: { day: "single", month: !0, year: !0, time: !1, controlTime: "all", stepHours: 1, stepMinutes: 1, cancelableDay: !0 }, selected: { dates: void 0, month: void 0, year: void 0, holidays: void 0, time: void 0 }, visibility: { theme: "system", themeDetect: "html[data-theme]", monthShort: !0, weekNumbers: !1, weekend: !0, today: !0, disabled: !1, daysOutside: !0, positionToInput: "left" } }), i(this, "locale", { months: [], weekday: [] }), i(this, "sanitizer", (e => e)), i(this, "actions", { clickDay: null, clickWeekNumber: null, clickMonth: null, clickYear: null, clickArrow: null, changeTime: null, changeToInput: null, getDays: null, getMonths: null, getYears: null, initCalendar: null, updateCalendar: null, destroyCalendar: null, showCalendar: null, hideCalendar: null }), i(this, "popups", {}), i(this, "CSSClasses", l({}, r)), i(this, "DOMTemplates", { default: (e = this.CSSClasses, `<div class="${e.header}"><#ArrowPrev /><div class="${e.headerContent}"><#Month /><#Year /></div><#ArrowNext /></div><div class="${e.wrapper}"><#WeekNumbers /><div class="${e.content}"><#Week /><#Days /></div></div><#ControlTime />`), multiple: d(this.CSSClasses), month: o(this.CSSClasses), year: c(this.CSSClasses) }), i(this, "HTMLElement"), i(this, "HTMLOriginalElement"), i(this, "HTMLInputElement"), i(this, "rangeMin"), i(this, "rangeMax"), i(this, "rangeDisabled"), i(this, "rangeEnabled"), i(this, "selectedDates"), i(this, "selectedHolidays"), i(this, "selectedMonth"), i(this, "selectedYear"), i(this, "selectedHours"), i(this, "selectedMinutes"), i(this, "selectedKeeping"), i(this, "selectedTime"), i(this, "currentType"), i(this, "correctMonths"), i(this, "viewYear"), i(this, "dateMin"), i(this, "dateMax") } } const m = e => `${e.getFullYear()}-${String(e.getMonth() + 1).padStart(2, "0")}-${String(e.getDate()).padStart(2, "0")}`, g = e => new Date(`${e}T00:00:00`), h = e => e.reduce(((e, t) => { if (t instanceof Date || "number" == typeof t) { const n = t instanceof Date ? t : new Date(t); e.push(n.toISOString().substring(0, 10)) } else t.match(/^(\d{4}-\d{2}-\d{2})$/g) ? e.push(t) : t.replace(/(\d{4}-\d{2}-\d{2}).*?(\d{4}-\d{2}-\d{2})/g, ((t, n, a) => { const s = g(n), l = g(a), i = new Date(s.getTime()); for (; i <= l; i.setDate(i.getDate() + 1))e.push(m(i)); return t })); return e }), []), y = () => { const e = new Date; return new Date(e.getTime() - 6e4 * e.getTimezoneOffset()).toISOString().substring(0, 10) }, v = e => e ? { 0: "12", 13: "01", 14: "02", 15: "03", 16: "04", 17: "05", 18: "06", 19: "07", 20: "08", 21: "09", 22: "10", 23: "11" }[Number(e)] || String(e) : "", p = e => `${e} is not found, check the first argument passed to new VanillaCalendar.`, S = 'The calendar has not been initialized, please initialize it using the "init()" method first.', M = 'You specified "define" for "settings.lang" but did not provide the required values for "locale.weekday" or "locale.months".', C = 'Incorrect name of theme in "settings.visibility.theme".', b = "The value of the time property can be: false, true, 12 or 24.", f = e => { e.currentType = e.type, (e => { var t; if (e.jumpToSelectedDate && (null == (t = e.settings.selected.dates) ? void 0 : t.length) && void 0 === e.settings.selected.month && void 0 === e.settings.selected.year) { const t = g(h(e.settings.selected.dates)[0]); e.settings.selected.month = t.getMonth(), e.settings.selected.year = t.getFullYear() } const n = void 0 !== e.settings.selected.month && Number(e.settings.selected.month) >= 0 && Number(e.settings.selected.month) < 12, a = void 0 !== e.settings.selected.year && Number(e.settings.selected.year) >= 0 && Number(e.settings.selected.year) <= 9999; e.selectedMonth = n ? Number(e.settings.selected.month) : e.date.today.getMonth(), e.selectedYear = a ? Number(e.settings.selected.year) : e.date.today.getFullYear(), e.viewYear = e.selectedYear })(e), (e => { var t, n, a; "today" === e.date.min && (e.date.min = y()), "today" === e.date.max && (e.date.max = y()), "today" === e.settings.range.min && (e.settings.range.min = y()), "today" === e.settings.range.max && (e.settings.range.max = y()), e.settings.range.min = e.settings.range.min ? g(e.date.min) >= g(e.settings.range.min) ? e.date.min : e.settings.range.min : e.date.min, e.settings.range.max = e.settings.range.max ? g(e.date.max) <= g(e.settings.range.max) ? e.date.max : e.settings.range.max : e.date.max; const s = e.settings.range.disablePast && !e.settings.range.disableAllDays && g(e.settings.range.min) < e.date.today; e.rangeMin = s || e.settings.range.disableAllDays ? m(e.date.today) : e.settings.range.min, e.rangeMax = e.settings.range.disableAllDays ? m(e.date.today) : e.settings.range.max, e.rangeDisabled = e.settings.range.disabled && !e.settings.range.disableAllDays ? h(e.settings.range.disabled) : e.settings.range.disableAllDays ? [e.rangeMin] : [], e.rangeDisabled.length > 1 && e.rangeDisabled.sort(((e, t) => +new Date(e) - +new Date(t))), e.rangeEnabled = e.settings.range.enabled ? h(e.settings.range.enabled) : [], (null == (t = e.rangeEnabled) ? void 0 : t[0]) && (null == (n = e.rangeDisabled) ? void 0 : n[0]) && (e.rangeDisabled = e.rangeDisabled.filter((t => !e.rangeEnabled.includes(t)))), e.rangeEnabled.length > 1 && e.rangeEnabled.sort(((e, t) => +new Date(e) - +new Date(t))), (null == (a = e.rangeEnabled) ? void 0 : a[0]) && e.settings.range.disableAllDays && (e.rangeMin = e.rangeEnabled[0], e.rangeMax = e.rangeEnabled[e.rangeEnabled.length - 1]) })(e), (e => { var t, n; e.selectedDates = (null == (t = e.settings.selected.dates) ? void 0 : t[0]) ? h(e.settings.selected.dates) : [], e.selectedHolidays = (null == (n = e.settings.selected.holidays) ? void 0 : n[0]) ? h(e.settings.selected.holidays) : [] })(e), (e => { e.dateMin = e.settings.visibility.disabled ? g(e.date.min) : g(e.rangeMin), e.dateMax = e.settings.visibility.disabled ? g(e.date.max) : g(e.rangeMax) })(e), (e => { const t = !0 === e.settings.selection.time || 12 === e.settings.selection.time; if (t || 24 === e.settings.selection.time) { let n = !1; if ("string" == typeof e.settings.selected.time) { const a = t ? /^([0-9]|0[1-9]|1[0-2]):([0-5][0-9])|(AM|PM)/g : /^([0-1]?[0-9]|2[0-3]):([0-5][0-9])/g; e.settings.selected.time.replace(a, ((a, s, l, i) => (s && l && (n = !0, e.selectedHours = s, e.selectedMinutes = l), i && t ? e.selectedKeeping = i : t && (e.selectedKeeping = "AM"), ""))) } !n && t ? (e.selectedHours = v(String(e.date.today.getHours())), e.selectedMinutes = String(e.date.today.getMinutes()), e.selectedKeeping = Number(e.date.today.getHours()) >= 12 ? "PM" : "AM") : n || (e.selectedHours = String(e.date.today.getHours()), e.selectedMinutes = String(e.date.today.getMinutes())), e.selectedHours = Number(e.selectedHours) < 10 ? `0${Number(e.selectedHours)}` : `${e.selectedHours}`, e.selectedMinutes = Number(e.selectedMinutes) < 10 ? `0${Number(e.selectedMinutes)}` : `${e.selectedMinutes}`, e.selectedTime = `${e.selectedHours}:${e.selectedMinutes}${e.selectedKeeping ? ` ${e.selectedKeeping}` : ""}` } else if (e.settings.selection.time) throw new Error(b) })(e), (e => { e.correctMonths = "multiple" === e.type ? 1 === e.months ? 2 : e.months > 12 ? 12 : e.months : 1 })(e) }, w = ({ arrowPrev: e, arrowNext: t, isPrevHidden: n, isNextHidden: a }) => { e.style.visibility = n ? "hidden" : "", t.style.visibility = a ? "hidden" : "" }, D = e => { var t, n; if ("month" === e.currentType) return; const a = null == (t = e.HTMLElement) ? void 0 : t.querySelector(`.${e.CSSClasses.arrowPrev}`), s = null == (n = e.HTMLElement) ? void 0 : n.querySelector(`.${e.CSSClasses.arrowNext}`); if (!a || !s) return; ({ default: () => { const t = g(m(new Date(e.selectedYear, e.selectedMonth, 1))), n = new Date(t.getTime()), l = new Date(t.getTime()); n.setMonth(n.getMonth() - e.jumpMonths), l.setMonth(l.getMonth() + e.jumpMonths), e.settings.selection.year || (e.dateMin.setFullYear(t.getFullYear()), e.dateMax.setFullYear(t.getFullYear())); const i = !e.settings.selection.month || n.getFullYear() < e.dateMin.getFullYear() || n.getFullYear() === e.dateMin.getFullYear() && n.getMonth() < e.dateMin.getMonth(), r = !e.settings.selection.month || l.getFullYear() > e.dateMax.getFullYear() || l.getFullYear() === e.dateMax.getFullYear() && l.getMonth() > e.dateMax.getMonth(); w({ arrowPrev: a, arrowNext: s, isPrevHidden: i, isNextHidden: r }) }, year: () => { w({ arrowPrev: a, arrowNext: s, isPrevHidden: e.dateMin.getFullYear() && e.viewYear - 7 <= e.dateMin.getFullYear(), isNextHidden: e.dateMax.getFullYear() && e.viewYear + 7 >= e.dateMax.getFullYear() }) } })["multiple" === e.currentType ? "default" : e.currentType]() }, T = (e, t) => { if (!e) return null; const n = g(e), a = t ? n.getDay() || 7 : n.getDay(); n.setDate(n.getDate() + 4 - a); const s = new Date(n.getFullYear(), 0, 1), l = Math.ceil(((+n - +s) / 864e5 + 1) / 7); return { year: n.getFullYear(), week: l } }; function L(e) { if (!e || !e.getBoundingClientRect) return { top: 0, bottom: 0, left: 0, right: 0 }; const t = e.getBoundingClientRect(), n = document.documentElement; return { bottom: t.bottom, right: t.right, top: t.top + window.scrollY - n.clientTop, left: t.left + window.scrollX - n.clientLeft } } function E() { return { vw: Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0), vh: Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0) } } function $(e) { const { top: t, left: n } = { left: window.scrollX || document.documentElement.scrollLeft || 0, top: window.scrollY || document.documentElement.scrollTop || 0 }, { top: a, left: s } = L(e), { vh: l, vw: i } = E(), r = a - t, d = s - n; return { top: r, bottom: l - (r + e.clientHeight), left: d, right: i - (d + e.clientWidth) } } function H(e, t, n = 5) { const a = { top: !0, bottom: !0, left: !0, right: !0 }, s = []; if (!t || !e) return { canShow: a, parentPositions: s }; const { bottom: l, top: i } = $(e), { top: r, left: d } = L(e), { height: o, width: c } = t.getBoundingClientRect(), { vh: u, vw: m } = E(), g = m / 2, h = u / 2; return [{ condition: r < h, position: "top" }, { condition: r > h, position: "bottom" }, { condition: d < g, position: "left" }, { condition: d > g, position: "right" }].forEach((({ condition: e, position: t }) => { e && s.push(t) })), Object.assign(a, { top: o <= i - n, bottom: o <= l - n, left: c <= d, right: c <= m - d }), { canShow: a, parentPositions: s } } const k = (e, t, n, a) => { if (e) { const s = "auto" === n ? function (e, t) { const n = "left"; if (!t || !e) return n; const { canShow: a, parentPositions: s } = H(e, t), l = a.left && a.right; return (l && a.bottom ? "center" : l && a.top ? ["top", "center"] : Array.isArray(s) ? ["bottom" === s[0] ? "top" : "bottom", ...s.slice(1)] : s) || n }(e, t) : n, l = { top: -t.offsetHeight, bottom: e.offsetHeight, left: 0, center: e.offsetWidth / 2 - t.offsetWidth / 2, right: e.offsetWidth - t.offsetWidth }, i = Array.isArray(s) ? s[0] : "bottom", r = Array.isArray(s) ? s[1] : s; "bottom" === i ? (t.classList.remove(a.calendarToInputTop), t.classList.add(a.calendarToInputBottom)) : (t.classList.remove(a.calendarToInputBottom), t.classList.add(a.calendarToInputTop)); const { top: d, left: o } = L(e), c = d + l[i], u = o + l[r]; Object.assign(t.style, { left: `${u}px`, top: `${c}px` }) } }, x = (e, t) => { var n; e.popups && (null == (n = Object.entries(e.popups)) || n.forEach((([n, a]) => ((e, t, n, a) => { const s = e.CSSClasses.dayPopup, l = a.querySelector(`[data-calendar-day="${t}"]`); if (l && ((null == n ? void 0 : n.modifier) && l.classList.add(...n.modifier.trim().split(" ")), null == n ? void 0 : n.html)) { const t = l.parentElement, a = document.createElement("div"); a.className = s, a.innerHTML = e.sanitizer(n.html), t.appendChild(a), setTimeout((() => { if (a) { const { canShow: e } = H(t, a), n = 5; let s = t.offsetHeight, l = 0; e.bottom || (s = -a.offsetHeight - n), e.left && !e.right && (l = t.offsetWidth - a.offsetWidth / 2), !e.left && e.right && (l = a.offsetWidth / 2), Object.assign(a.style, { left: `${l}px`, top: `${s}px` }) } })) } })(e, n, a, t)))) }, Y = (e, t, n, a, s) => { const l = t[n].querySelector(`.${e.CSSClasses.dayBtn}`), i = T(null == l ? void 0 : l.dataset.calendarDay, e.settings.iso8601); if (!i) return; const r = a.cloneNode(!0); r.innerText = String(i.week), r.dataset.calendarYearWeek = String(i.year), s.appendChild(r) }, _ = (e, t, n, a, s, l, i, r) => { const d = document.createElement("div"); d.className = e.CSSClasses.day; const o = document.createElement("button"); o.className = `${e.CSSClasses.dayBtn}${r ? ` ${r}` : ""}`, o.type = "button", o.innerText = String(a), o.dataset.calendarDay = l; e.settings.visibility.weekNumbers && (() => { const t = T(l, e.settings.iso8601); t && (o.dataset.calendarWeekNumber = String(t.week)) })(), i ? e.settings.visibility.daysOutside && d.appendChild(o) : d.appendChild(o), ((e, t, n) => { var a, s, l, i, r; const d = null == (a = e.settings.range.disableWeekday) ? void 0 : a.includes(n), o = e.settings.range.disableAllDays && !!(null == (s = e.rangeEnabled) ? void 0 : s[0]); !d && !o || (null == (l = e.rangeEnabled) ? void 0 : l.includes(t)) || (null == (i = e.rangeDisabled) ? void 0 : i.includes(t)) || (e.rangeDisabled.push(t), null == (r = e.rangeDisabled) || r.sort(((e, t) => +new Date(e) - +new Date(t)))) })(e, l, s), ((e, t, n, a, s, l, i) => { var r, d, o; if ((g(e.rangeMin) > g(l) || g(e.rangeMax) < g(l) || (null == (r = e.rangeDisabled) ? void 0 : r.includes(l)) || !e.settings.selection.month && i || !e.settings.selection.year && g(l).getFullYear() !== t) && (a.classList.add(e.CSSClasses.dayBtnDisabled), a.tabIndex = -1), e.settings.visibility.today && m(e.date.today) === l && a.classList.add(e.CSSClasses.dayBtnToday), !e.settings.visibility.weekend || 0 !== s && 6 !== s || a.classList.add(e.CSSClasses.dayBtnWeekend), (null == (d = e.selectedHolidays) ? void 0 : d.includes(l)) && a.classList.add(e.CSSClasses.dayBtnHoliday), (null == (o = e.selectedDates) ? void 0 : o.includes(l)) && (a.classList.add(e.CSSClasses.dayBtnSelected), e.selectedDates.length > 1 && "multiple-ranged" === e.settings.selection.day && (e.selectedDates[0] === l && n.classList.add(e.CSSClasses.daySelectedFirst), e.selectedDates[e.selectedDates.length - 1] === l && n.classList.add(e.CSSClasses.daySelectedLast), e.selectedDates[0] !== l && e.selectedDates[e.selectedDates.length - 1] !== l && n.classList.add(e.CSSClasses.daySelectedIntermediate))), e.settings.range.edgesOnly && e.selectedDates.length > 1 && "multiple-ranged" === e.settings.selection.day) { const t = +new Date(e.selectedDates[0]), s = +new Date(e.selectedDates[e.selectedDates.length - 1]), i = +new Date(l); i > t && i < s && (a.classList.add(e.CSSClasses.dayBtnSelected), n.classList.add(e.CSSClasses.daySelectedIntermediate)) } })(e, t, d, o, s, l, i), n.appendChild(d), e.actions.getDays && e.actions.getDays(a, l, d, o, e) }, N = e => { const t = e.HTMLElement.querySelectorAll(`.${e.CSSClasses.days}`), n = e.HTMLElement.querySelectorAll(`.${e.CSSClasses.weekNumbers}`), a = new Date(e.selectedYear, e.selectedMonth, 1); t.forEach(((t, s) => { const l = new Date(a); l.setMonth(l.getMonth() + s); const i = l.getMonth(), r = l.getFullYear(), d = new Date(r, i, 1), o = new Date(r, i + 1, 0).getDate(), c = e.settings.iso8601 ? (0 !== d.getDay() ? d.getDay() : 7) - 1 : d.getDay(); e.settings.selection.day && t.classList.add(e.CSSClasses.daysSelecting), t.textContent = "", ((e, t, n, a, s) => { let l = new Date(n, a, 0).getDate() - (s - 1); const i = 0 === a ? n - 1 : n, r = 0 === a ? 12 : a < 10 ? `0${a}` : a; for (let a = s; a > 0; a--, l++) { const a = `${i}-${r}-${l}`, s = g(a).getDay(); _(e, n, t, l, s, a, !0, e.CSSClasses.dayBtnPrev) } })(e, t, r, i, c), ((e, t, n, a, s) => { for (let l = 1; l <= n; l++) { const n = new Date(a, s, l), i = m(n), r = n.getDay(); _(e, a, t, l, r, i, !1, null) } })(e, t, o, r, i), ((e, t, n, a, s, l) => { const i = l + n, r = 7 * Math.ceil(i / 7) - i, d = s + 1 === 12 ? a + 1 : a, o = s + 1 === 12 ? "01" : s + 2 < 10 ? `0${s + 2}` : s + 2; for (let n = 1; n <= r; n++) { const s = `${d}-${o}-${n < 10 ? `0${n}` : String(n)}`, l = g(s).getDay(); _(e, a, t, n, l, s, !0, e.CSSClasses.dayBtnNext) } })(e, t, o, r, i, c), ((e, t, n, a, s) => { if (!e.settings.visibility.weekNumbers) return; a.textContent = ""; const l = document.createElement("b"); l.className = e.CSSClasses.weekNumbersTitle, l.innerText = "#", a.appendChild(l); const i = document.createElement("div"); i.className = e.CSSClasses.weekNumbersContent, a.appendChild(i); const r = document.createElement("button"); r.type = "button", r.className = e.CSSClasses.weekNumber; const d = s.querySelectorAll(`.${e.CSSClasses.day}`), o = Math.ceil((t + n) / 7); for (let t = 0; t < o; t++)Y(e, d, 0 === t ? 6 : 7 * t, r, i) })(e, c, o, n[s], t), x(e, t) })) }, A = e => { var t, n; const a = null == (t = e.HTMLElement) ? void 0 : t.querySelectorAll("[data-calendar-selected-month]"), s = null == (n = e.HTMLElement) ? void 0 : n.querySelectorAll("[data-calendar-selected-year]"); if (!(null == a ? void 0 : a[0]) && (null == s ? void 0 : s[0])) return; const l = new Date(e.selectedYear, e.selectedMonth, 1); null == a || a.forEach(((t, n) => ((e, t, n, a) => { const s = new Date(a.setMonth(e.selectedMonth + n)).getMonth(), l = !1 === e.settings.selection.month || "only-arrows" === e.settings.selection.month; t.tabIndex = l ? -1 : 0, t.classList.toggle(e.CSSClasses.monthDisabled, l), t.setAttribute("data-calendar-selected-month", String(s)), t.innerText = e.locale.months[s] })(e, t, n, l))), null == s || s.forEach(((t, n) => ((e, t, n, a) => { const s = new Date(a.setFullYear(e.selectedYear, e.selectedMonth + n)).getFullYear(), l = !1 === e.settings.selection.year || "only-arrows" === e.settings.selection.year; t.tabIndex = l ? -1 : 0, t.classList.toggle(e.CSSClasses.yearDisabled, l), t.setAttribute("data-calendar-selected-year", String(s)), t.innerText = String(s) })(e, t, n, l))) }, I = (e, t) => { const n = g(m(new Date(e.selectedYear, e.selectedMonth, 1))); ({ prev: () => n.setMonth(n.getMonth() - e.jumpMonths), next: () => n.setMonth(n.getMonth() + e.jumpMonths) })[t](), [e.selectedMonth, e.selectedYear] = [n.getMonth(), n.getFullYear()], A(e), D(e), N(e) }, P = Object.freeze(Object.defineProperty({ __proto__: null, ArrowNext: e => `<button type="button"class="${e.CSSClasses.arrow} ${e.CSSClasses.arrowNext}"data-calendar-arrow="next"></button>`, ArrowPrev: e => `<button type="button"class="${e.CSSClasses.arrow} ${e.CSSClasses.arrowPrev}"data-calendar-arrow="prev"></button>`, ControlTime: e => e.settings.selection.time ? `<div class="${e.CSSClasses.time}"></div>` : "", Days: e => `<div class="${e.CSSClasses.days}"></div>`, Month: e => `<button type="button"class="${e.CSSClasses.month}"data-calendar-selected-month></button>`, Months: e => `<div class="${e.CSSClasses.months}"></div>`, Week: e => `<div class="${e.CSSClasses.week}"></div>`, WeekNumbers: e => e.settings.visibility.weekNumbers ? `<div class="${e.CSSClasses.weekNumbers}"></div>` : "", Year: e => `<button type="button"class="${e.CSSClasses.year}"data-calendar-selected-year></button>`, Years: e => `<div class="${e.CSSClasses.years}"></div>` }, Symbol.toStringTag, { value: "Module" })), F = (e, t) => t.replace(/[\n\t]/g, "").replace(/<#(?!\/?Multiple)(.*?)>/g, ((t, n) => { const a = (s = n.replace(/[/\s\n\t]/g, ""), P[s]); var s; const l = a ? a(e) : ""; return e.sanitizer(l) })).replace(/[\n\t]/g, ""), q = (e, t) => { const { HTMLElement: n, CSSClasses: a, DOMTemplates: s, type: l, currentType: i, correctMonths: r } = e, d = (s, l) => { if (!t) return; const i = n.querySelector(`.${a.controls}`); i && n.removeChild(i); n.querySelector(`.${a.grid}`).classList.add(a.gridDisabled); const r = t.closest(`.${a.column}`); r.classList.add(s), r.innerHTML = F(e, l) }, o = { default: () => { n.classList.add(a.calendarDefault), n.classList.remove(a.calendarMonth, a.calendarYear), n.innerHTML = F(e, s.default) }, multiple: () => { r && (n.classList.add(a.calendarMultiple), n.classList.remove(a.calendarMonth, a.calendarYear), n.innerHTML = ((e, t) => t.replace(/<#Multiple>(.*?)<#\/Multiple>/g, ((t, n) => { let a = ""; for (let t = 0; t < e.correctMonths; t++)a += n; return e.sanitizer(a) })).replace(/[\n\t]/g, ""))(e, F(e, s.multiple))) }, month: () => { "multiple" !== l ? (n.classList.add(a.calendarMonth), n.classList.remove(a.calendarDefault, a.calendarYear), n.innerHTML = F(e, s.month)) : d(a.columnMonth, s.month) }, year: () => { "multiple" !== l ? (n.classList.add(a.calendarYear), n.classList.remove(a.calendarDefault, a.calendarMonth), n.innerHTML = F(e, s.year)) : d(a.columnYear, s.year) } }; n.classList.add(a.calendar), o[i]() }, B = (e, t, n, a, s) => { const l = t.cloneNode(!1); return l.className = `${e.CSSClasses.yearsYear}${n === s ? ` ${e.CSSClasses.yearsYearSelected}` : a ? ` ${e.CSSClasses.yearsYearDisabled}` : ""}`, l.dataset.calendarYear = String(s), l.title = String(s), l.innerText = String(s), a && (l.tabIndex = -1), l }, W = (e, t) => { const n = (null == t ? void 0 : t.dataset.calendarSelectedYear) ? Number(null == t ? void 0 : t.dataset.calendarSelectedYear) : e.selectedYear; e.currentType = "year", q(e, t), A(e), D(e); const a = e.HTMLElement.querySelector(`.${e.CSSClasses.years}`); if (!e.settings.selection.year || !a) return; a.classList.add(e.CSSClasses.yearsSelecting); const s = "multiple" !== e.type || e.selectedYear === n ? 0 : 1, l = document.createElement("button"); l.type = "button"; for (let t = e.viewYear - 7; t < e.viewYear + 8; t++) { const i = t < e.dateMin.getFullYear() + s || t > e.dateMax.getFullYear(), r = B(e, l, n, i, t); a.appendChild(r), e.actions.getYears && e.actions.getYears(t, r, e) } }, O = e => `${e.charAt(0).toUpperCase()}${e.substring(1, e.length)}`.replace(/\./, ""), j = (e, t) => { const n = new Date(`1978-01-0${t + 1}T00:00:00.000Z`).toLocaleString(e.settings.lang, { weekday: "short", timeZone: "UTC" }); e.locale.weekday.push(O(n)) }, K = (e, t) => { const n = new Date(`1978-${t + 1 <= 9 ? `0${t + 1}` : t + 1}-01T00:00:00.000Z`).toLocaleString(e.settings.lang, { month: "long", timeZone: "UTC" }); e.locale.months.push(O(n)) }, z = e => { if ("multiple" !== e.type) return 0; const t = e.HTMLElement.querySelectorAll(`.${e.CSSClasses.column}`), n = Array.from(t).findIndex((t => t.classList.contains(`${e.CSSClasses.columnMonth}`))); return n > 0 ? n : 0 }, R = (e, t, n, a, s, l) => { const i = t.cloneNode(!1); return i.className = `${e.CSSClasses.monthsMonth}${n === l ? ` ${e.CSSClasses.monthsMonthSelected}` : s ? ` ${e.CSSClasses.monthsMonthDisabled}` : ""}`, i.title = a, i.innerText = `${e.settings.visibility.monthShort ? a.substring(0, 3) : a}`, i.dataset.calendarMonth = String(l), s && (i.tabIndex = -1), i }, G = (e, t) => { var n, a; const s = (null == t ? void 0 : t.dataset.calendarSelectedMonth) ? Number(t.dataset.calendarSelectedMonth) : e.selectedMonth, l = null == (n = null == t ? void 0 : t.closest(`.${e.CSSClasses.column}`)) ? void 0 : n.querySelector(`.${e.CSSClasses.year}`), i = l ? Number(l.dataset.calendarSelectedYear) : e.selectedYear; e.currentType = "month", q(e, t), A(e); const r = null == (a = e.HTMLElement) ? void 0 : a.querySelector(`.${e.CSSClasses.months}`); if (!e.settings.selection.month || !r) return; r.classList.add(e.CSSClasses.monthsSelecting); const d = e.jumpMonths > 1 ? e.locale.months.map(((t, n) => s - e.jumpMonths * n)).concat(e.locale.months.map(((t, n) => s + e.jumpMonths * n))).filter((e => e >= 0 && e <= 12)) : Array.from(Array(12).keys()), o = document.createElement("button"); o.type = "button"; for (let t = 0; t < 12; t++) { const n = e.locale.months[t], a = t < e.dateMin.getMonth() + z(e) && i <= e.dateMin.getFullYear() || t > e.dateMax.getMonth() + z(e) && i >= e.dateMax.getFullYear() || t !== s && !d.includes(t), l = R(e, o, s, n, a, t); r.appendChild(l), e.actions.getMonths && e.actions.getMonths(t, l, e) } }, Z = (e, t) => e && t ? { 0: { AM: "00", PM: "12" }, 1: { AM: "01", PM: "13" }, 2: { AM: "02", PM: "14" }, 3: { AM: "03", PM: "15" }, 4: { AM: "04", PM: "16" }, 5: { AM: "05", PM: "17" }, 6: { AM: "06", PM: "18" }, 7: { AM: "07", PM: "19" }, 8: { AM: "08", PM: "20" }, 9: { AM: "09", PM: "21" }, 10: { AM: "10", PM: "22" }, 11: { AM: "11", PM: "23" }, 12: { AM: "12", PM: "12" } }[Number(e)][t] : "", U = (e, t, n) => e.querySelector(`.${t}${n ? ` input[name="${n}"]` : ""}`), V = (e, t, n) => { e.addEventListener("mouseover", (() => t.classList.add(n))), e.addEventListener("mouseout", (() => t.classList.remove(n))) }, X = (e, t, n, a) => { ({ hours: () => { e.selectedHours = n }, minutes: () => { e.selectedMinutes = n } })[a](), e.selectedTime = `${e.selectedHours}:${e.selectedMinutes}${e.selectedKeeping ? ` ${e.selectedKeeping}` : ""}`, e.actions.changeTime && e.actions.changeTime(t, e), e.input && e.HTMLInputElement && e.actions.changeToInput && e.actions.changeToInput(t, e) }, J = (e, t, n, a, s, l) => { t.addEventListener("input", (t => { const i = t.target, r = Number(i.value), d = r < 10 ? `0${r}` : `${r}`; if ("hours" !== s || 12 !== l) return n.value = d, void X(e, t, d, s); r < l && r > 0 ? (n.value = d, e.selectedKeeping = "AM", a.innerText = e.selectedKeeping, X(e, t, d, s)) : (0 === r ? (e.selectedKeeping = "AM", a.innerText = "AM") : (e.selectedKeeping = "PM", a.innerText = "PM"), n.value = v(i.value), X(e, t, v(i.value), s)) })) }, Q = (e, t, n, a, s, l) => { n.addEventListener("change", (n => { const i = n.target, r = Number(i.value), d = r < 10 ? `0${r}` : `${r}`; "hours" === s && 12 === l ? i.value && r <= l && r > 0 ? (i.value = d, t.value = Z(d, e.selectedKeeping), X(e, n, d, s)) : i.value && r < 24 && (r > l || 0 === r) ? (0 === r ? (e.selectedKeeping = "AM", a.innerText = "AM") : (e.selectedKeeping = "PM", a.innerText = "PM"), i.value = v(i.value), t.value = d, X(e, n, v(i.value), s)) : i.value = e.selectedHours : i.value && r <= l && r >= 0 ? (i.value = d, t.value = d, X(e, n, d, s)) : "hours" === s ? i.value = e.selectedHours : "minutes" === s && (i.value = e.selectedMinutes) })) }, ee = (e, t, n) => { const a = 24 === n ? 23 : n || 12, s = U(t, e.CSSClasses.timeRange, "hours"), l = U(t, e.CSSClasses.timeRange, "minutes"), i = U(t, e.CSSClasses.timeHours, "hours"), r = U(t, e.CSSClasses.timeMinutes, "minutes"), d = t.querySelector(`.${e.CSSClasses.timeKeeping}`); V(s, i, e.CSSClasses.isFocus), V(l, r, e.CSSClasses.isFocus), J(e, s, i, d, "hours", a), J(e, l, r, d, "minutes", 0), Q(e, s, i, d, "hours", a), Q(e, l, r, d, "minutes", 59), d && ((e, t, n) => { t.addEventListener("click", (a => { e.selectedKeeping = t.innerText.includes("AM") ? "PM" : "AM", t.innerText = e.selectedKeeping, n.value = Z(e.selectedHours, e.selectedKeeping), X(e, a, e.selectedHours, "hours") })) })(e, d, s) }, te = (e, t, n, a) => `<label class="${t}"><input type="text"name="${e}"maxlength="2"value="${n}"${a ? "disabled" : ""}></label>`, ne = (e, t, n, a, s, l) => `<label class="${t}"><input type="range"name="${e}"min="${n}"max="${a}"step="${s}"value="${l}"></label>`, ae = e => { const t = [...e.locale.weekday]; if (!t[0]) return; e.settings.iso8601 && t.push(t.shift()); e.HTMLElement.querySelectorAll(`.${e.CSSClasses.week}`).forEach((n => ((e, t, n) => { const a = document.createElement("b"); t.textContent = ""; for (let s = 0; s < n.length; s++) { const l = n[s], i = a.cloneNode(!0); i.className = `${e.CSSClasses.weekDay}`, i.className = `${e.CSSClasses.weekDay}${e.settings.visibility.weekend && e.settings.iso8601 ? 5 === s || 6 === s ? ` ${e.CSSClasses.weekDayWeekend}` : "" : !e.settings.visibility.weekend || e.settings.iso8601 || 0 !== s && 6 !== s ? "" : ` ${e.CSSClasses.weekDayWeekend}`}`, i.innerText = `${l}`, t.appendChild(i) } })(e, n, t))) }, se = ["light", "dark", "system"], le = { value: !1, set: () => { le.value = !0 }, check: () => le.value }, ie = (e, t) => se.find((n => { var a; return "system" !== n && (null == (a = e.getAttribute(t)) ? void 0 : a.includes(n)) })), re = (e, t) => { e.dataset.calendarTheme = t }, de = (e, t) => { var n; if (n = t, re(e.HTMLElement, n.matches ? "dark" : "light"), "system" !== e.settings.visibility.theme || le.check()) return; const a = t => { const n = document.querySelectorAll(`.${e.CSSClasses.calendar}`); null == n || n.forEach((e => re(e, t.matches ? "dark" : "light"))) }; t.addEventListener ? t.addEventListener("change", a) : t.addListener(a), le.set() }, oe = (e, t) => { const n = e.settings.visibility.themeDetect ? document.querySelector(e.settings.visibility.themeDetect) : null; if (!n) return void de(e, t); const a = e.settings.visibility.themeDetect.replace(/^.*\[(.+)\]/g, ((e, t) => t)), s = ie(n, a); s ? (re(e.HTMLElement, s), ((e, t, n) => { new MutationObserver((a => { for (let s = 0; s < a.length; s++)if (a[s].attributeName === n) { const a = ie(t, n); a && re(e.HTMLElement, a); break } })).observe(t, { attributes: !0 }) })(e, n, a)) : de(e, t) }, ce = e => { const t = { default: () => { ae(e), N(e) }, multiple: () => { ae(e), N(e) }, month: () => G(e), year: () => W(e) }; (e => { if (!se.includes(e.settings.visibility.theme)) throw new Error(C); if ("not all" === window.matchMedia("(prefers-color-scheme)").media) return void re(e.HTMLElement, "light"); ({ light: () => re(e.HTMLElement, "light"), dark: () => re(e.HTMLElement, "dark"), system: () => oe(e, window.matchMedia("(prefers-color-scheme: dark)")) })[e.settings.visibility.theme]() })(e), (e => { if ("define" !== e.settings.lang || !e.locale.weekday[6] || !e.locale.months[11]) { if ("define" === e.settings.lang) throw new Error(M); e.locale.weekday = [], e.locale.months = []; for (let t = 0; t < 7; t++)j(e, t); for (let t = 0; t < 12; t++)K(e, t) } })(e), q(e), A(e), D(e), (e => { const t = e.HTMLElement.querySelector(`.${e.CSSClasses.time}`); if (!t) return; const n = !0 === e.settings.selection.time ? 12 : e.settings.selection.time, a = "range" === e.settings.selection.controlTime, [s, l] = [0, 23], [i, r] = [0, 59]; t.innerHTML = e.sanitizer(`<div class="${e.CSSClasses.timeContent}">${te("hours", e.CSSClasses.timeHours, e.selectedHours, a)}${te("minutes", e.CSSClasses.timeMinutes, e.selectedMinutes, a)}${12 === n ? `<button type="button" class="${e.CSSClasses.timeKeeping}"${a ? "disabled" : ""}>${e.selectedKeeping}</button>` : ""}</div><div class="${e.CSSClasses.timeRanges}">${ne("hours", e.CSSClasses.timeRange, s, l, e.settings.selection.stepHours, e.selectedKeeping ? Z(e.selectedHours, e.selectedKeeping) : e.selectedHours)}${ne("minutes", e.CSSClasses.timeRange, i, r, e.settings.selection.stepMinutes, e.selectedMinutes)}</div>`), ee(e, t, n) })(e), t[e.currentType]() }, ue = { self: null, rangeMin: void 0, rangeMax: void 0 }, me = () => { var e; if (!(null == (e = ue.self) ? void 0 : e.HTMLElement)) return; const { CSSClasses: t } = ue.self; ue.self.HTMLElement.querySelectorAll(`.${ue.self.CSSClasses.dayBtnHover}`).forEach((e => { var n; e.classList.remove(ue.self.CSSClasses.dayBtnHover), null == (n = e.parentElement) || n.classList.remove(t.dayHoverIntermediate, t.dayHoverFirst, t.dayHoverLast) })) }, ge = (e, t, n) => { var a, s, l; if (!(null == (a = ue.self) ? void 0 : a.selectedDates)) return; const i = m(e), { CSSClasses: r } = ue.self; if (null == (s = ue.self.rangeDisabled) ? void 0 : s.includes(i)) return; const d = null == (l = ue.self.HTMLElement) ? void 0 : l.querySelectorAll(`[data-calendar-day="${i}"]`); null == d || d.forEach((e => { var t; e.classList.add(r.dayBtnHover), null == (t = e.parentElement) || t.classList.add(r.dayHoverIntermediate) })), null == t || t.forEach((e => { var t; return null == (t = e.parentElement) ? void 0 : t.classList.add(r.dayHoverFirst) })), null == n || n.forEach((e => { var t; return null == (t = e.parentElement) ? void 0 : t.classList.add(r.dayHoverLast) })) }, he = e => { var t; if (!e.target || !(null == (t = ue.self) ? void 0 : t.selectedDates)) return; if (!e.target.closest(`.${ue.self.CSSClasses.days}`)) return void me(); const n = e.target.closest("[data-calendar-day]"); if (!n) return; const a = n.dataset.calendarDay, s = g(ue.self.selectedDates[0]), l = g(a), i = ue.self.HTMLElement.querySelectorAll(`[data-calendar-day="${ue.self.selectedDates[0]}"]`), r = ue.self.HTMLElement.querySelectorAll(`[data-calendar-day="${a}"]`), [d, o] = s < l ? [i, r] : [r, i], [c, u] = s < l ? [s, l] : [l, s]; me(); for (let e = new Date(c); e <= u; e.setDate(e.getDate() + 1))ge(e, d, o) }, ye = e => { ue.self && "Escape" === e.key && (ue.self.selectedDates = [], ue.self.HTMLElement.removeEventListener("mousemove", he), document.removeEventListener("keydown", ye), ce(ue.self)) }, ve = (e, t) => { var n; if (t) { const a = 1 === e.selectedDates.length && e.selectedDates[0].includes(t); e.selectedDates = a && !e.settings.selection.cancelableDay ? [t, t] : a && e.settings.selection.cancelableDay ? [] : e.selectedDates.length > 1 ? [t] : [...e.selectedDates, t], null == (n = e.selectedDates) || n.sort(((e, t) => +new Date(e) - +new Date(t))) } e.settings.range.disableGaps && (ue.rangeMin = ue.rangeMin ? ue.rangeMin : e.rangeMin, ue.rangeMax = ue.rangeMax ? ue.rangeMax : e.rangeMax), ue.self = e; const a = { set: () => { e.HTMLElement.addEventListener("mousemove", he), document.addEventListener("keydown", ye), e.settings.range.disableGaps && (() => { var e, t, n; if (!(null == (t = null == (e = ue.self) ? void 0 : e.selectedDates) ? void 0 : t[0]) || !(null == (n = ue.self.rangeDisabled) ? void 0 : n[0])) return; const a = g(ue.self.selectedDates[0]), [s, l] = ue.self.rangeDisabled.map((e => g(e))).reduce((([e, t], n) => [a >= n ? n : e, a < n && null === t ? n : t]), [null, null]); s && (ue.self.rangeMin = m(new Date(s.setDate(s.getDate() + 1)))), l && (ue.self.rangeMax = m(new Date(l.setDate(l.getDate() - 1)))) })() }, reset: () => { const [t, n] = [e.selectedDates[0], e.selectedDates[e.selectedDates.length - 1]]; e.selectedDates = e.selectedDates[0] !== e.selectedDates[e.selectedDates.length - 1] ? e.settings.range.edgesOnly ? [t, n] : h([`${t}:${n}`]) : [e.selectedDates[0], e.selectedDates[0]], e.HTMLElement.removeEventListener("mousemove", he), document.removeEventListener("keydown", ye), e.settings.range.disableGaps && ue.self && (ue.self.rangeMin = ue.rangeMin, ue.self.rangeMax = ue.rangeMax) } }; a[1 === e.selectedDates.length ? "set" : "reset"]() }, pe = (e, t, n) => { if (!t.dataset.calendarDay) return; const a = t.dataset.calendarDay, s = t.classList.contains(e.CSSClasses.dayBtnSelected); if (s && !e.settings.selection.cancelableDay) return; let l = !0; void 0 !== e.toggleSelected && (l = "function" == typeof e.toggleSelected ? e.toggleSelected(e) : e.toggleSelected), s && !l || (e.selectedDates = s ? e.selectedDates.filter((e => e !== a)) : n ? [...e.selectedDates, a] : [a]) }, Se = (e, t, n, a, s) => { const l = e.HTMLElement.querySelectorAll(`.${e.CSSClasses.column}`), i = Array.from(l).findIndex((e => e.classList.contains(t))), r = Number(l[i].querySelector(`.${n}`).getAttribute(s)); return "month" === e.currentType && i >= 0 ? a - i : "year" === e.currentType && e.selectedYear !== r ? a - 1 : a }, Me = (e, t, n, a) => { if (!e.settings.selection[n]) return; const s = t.target, l = e => s.closest(`.${e}`), i = l(a.header), r = l(a.item), d = l(e.CSSClasses.grid), o = l(e.CSSClasses.column); if (e.currentType !== n && i) { ({ year: () => W(e, s), month: () => G(e, s) })[n]() } else r ? ((e, t, n, a, s) => { const l = { year: () => { var n, a; return null == (a = (n = e.actions).clickYear) ? void 0 : a.call(n, t, e) }, month: () => { var n, a; return null == (a = (n = e.actions).clickMonth) ? void 0 : a.call(n, t, e) } }; ({ year: () => { if ("multiple" === e.type) { const t = Se(e, e.CSSClasses.columnYear, e.CSSClasses.year, Number(s.dataset.calendarYear), "data-calendar-selected-year"), n = e.selectedMonth < e.dateMin.getMonth() && t <= e.dateMin.getFullYear(), a = e.selectedMonth > e.dateMax.getMonth() && t >= e.dateMax.getFullYear(), l = t < e.dateMin.getFullYear(), i = t > e.dateMax.getFullYear(); n || l ? (e.selectedYear = e.dateMin.getFullYear(), e.selectedMonth = e.dateMin.getMonth()) : a || i ? (e.selectedYear = e.dateMax.getFullYear(), e.selectedMonth = e.dateMax.getMonth()) : e.selectedYear = t } else e.selectedYear = Number(s.dataset.calendarYear) }, month: () => { if ("multiple" === e.type) { const t = Se(e, e.CSSClasses.columnMonth, e.CSSClasses.month, Number(s.dataset.calendarMonth), "data-calendar-selected-month"), n = s.closest(`.${a.column}`).querySelector(`.${e.CSSClasses.year}`); e.selectedYear = Number(n.dataset.calendarSelectedYear); const l = t < e.dateMin.getMonth() && e.selectedYear <= e.dateMin.getFullYear(), i = t > e.dateMax.getMonth() && e.selectedYear >= e.dateMax.getFullYear(); e.selectedMonth = l ? e.dateMin.getMonth() : i ? e.dateMax.getMonth() : t } else e.selectedMonth = Number(s.dataset.calendarMonth) } })[n](), l[n](), e.currentType = e.type, ce(e) })(e, t, n, a, r) : (e.currentType === n && i || "multiple" === e.type && e.currentType === n && d && !o) && (e.currentType = e.type, ce(e)) }, Ce = e => { const t = t => { ((e, t) => { const n = t.target.closest(`.${e.CSSClasses.arrow}`); n && (["default", "multiple"].includes(e.currentType) ? I(e, n.dataset.calendarArrow) : "year" === e.currentType && void 0 !== e.viewYear && (e.viewYear += { prev: -15, next: 15 }[n.dataset.calendarArrow], W(e, t.target)), e.actions.clickArrow && e.actions.clickArrow(t, e)) })(e, t), ((e, t) => { var n; if (!e.settings.visibility.weekNumbers || !e.actions.clickWeekNumber) return; const a = t.target.closest(`.${e.CSSClasses.weekNumber}`), s = null == (n = e.HTMLElement) ? void 0 : n.querySelectorAll("[data-calendar-week-number]"); if (!a || !s) return; const l = Number(a.innerText), i = Number(a.dataset.calendarYearWeek), r = Array.from(s).filter((e => Number(e.dataset.calendarWeekNumber) === l)); e.actions.clickWeekNumber(t, l, r, i, e) })(e, t), ((e, t) => { var n; const a = t.target, s = e => a.closest(`.${e}`), l = s(e.CSSClasses.dayBtn); if (!e.settings.selection.day || !["single", "multiple", "multiple-ranged"].includes(e.settings.selection.day) || !l) return; ({ single: () => pe(e, l, !1), multiple: () => pe(e, l, !0), "multiple-ranged": () => ve(e, l.dataset.calendarDay) })[e.settings.selection.day](), null == (n = e.selectedDates) || n.sort(((e, t) => +new Date(e) - +new Date(t))), e.actions.clickDay && e.actions.clickDay(t, e), e.input && e.HTMLInputElement && e.HTMLElement && e.actions.changeToInput && e.actions.changeToInput(t, e); const i = s(e.CSSClasses.dayBtnPrev), r = s(e.CSSClasses.dayBtnNext); ({ prev: () => I(e, "prev"), next: () => I(e, "next"), default: () => N(e) })[i ? "prev" : r ? "next" : "default"]() })(e, t), Me(e, t, "month", { header: e.CSSClasses.month, item: e.CSSClasses.monthsMonth, column: e.CSSClasses.columnMonth }), Me(e, t, "year", { header: e.CSSClasses.year, item: e.CSSClasses.yearsYear, column: e.CSSClasses.columnYear }) }; return e.HTMLElement.addEventListener("click", t), () => e.HTMLElement.removeEventListener("click", t) }, be = (e, { year: t, month: n, dates: a, holidays: s, time: i } = {}) => { var r; const d = l({}, e.settings.selected); e.settings.selected.year = t ? d.year : e.selectedYear, e.settings.selected.month = n ? d.month : e.selectedMonth, e.settings.selected.holidays = s ? d.holidays : e.selectedHolidays, e.settings.selected.time = i ? d.time : e.selectedTime, e.settings.selected.dates = "only-first" === a && (null == (r = e.selectedDates) ? void 0 : r[0]) ? [e.selectedDates[0]] : !0 === a ? d.dates : e.selectedDates, f(e), ce(e), e.settings.selected = d, "multiple-ranged" === e.settings.selection.day && a && ve(e) }, fe = (e, t = !0) => { e.isInputInit = !0; const n = document.createElement("div"); return n.className = `${e.CSSClasses.calendar} ${e.CSSClasses.calendarToInput} ${e.CSSClasses.calendarHidden}`, e.HTMLElement = n, document.body.appendChild(e.HTMLElement), e.HTMLElement.style.visibility = "hidden", t && queueMicrotask((() => { k(e.HTMLInputElement, n, e.settings.visibility.positionToInput, e.CSSClasses), e.HTMLElement.style.visibility = "visible", e.show() })), be(e, { year: !0, month: !0, dates: !0, holidays: !0, time: !0 }), e.actions.initCalendar && e.actions.initCalendar(e), Ce(e) }, we = e => (e.HTMLOriginalElement = e.HTMLElement.cloneNode(!0), e.isInit = !0, e.input ? (e => { const t = []; e.HTMLInputElement = e.HTMLElement; const n = () => k(e.HTMLInputElement, e.HTMLElement, e.settings.visibility.positionToInput, e.CSSClasses), a = t => { "Escape" === t.key && ((null == e ? void 0 : e.HTMLInputElement) && (null == e ? void 0 : e.HTMLElement) && e.hide(), document.removeEventListener("keydown", a)) }, s = t => { var a; e && t.target !== e.HTMLInputElement && !(null == (a = e.HTMLElement) ? void 0 : a.contains(t.target)) && (e.HTMLInputElement && e.HTMLElement && e.hide(), window.removeEventListener("resize", n), document.removeEventListener("click", s, { capture: !0 })) }, l = () => { e.isInputInit ? (k(e.HTMLInputElement, e.HTMLElement, e.settings.visibility.positionToInput, e.CSSClasses), e.HTMLElement.style.visibility = "visible", e.show()) : t.push(fe(e)), window.addEventListener("resize", n), document.addEventListener("click", s, { capture: !0 }), document.addEventListener("keydown", a) }; return e.HTMLInputElement.addEventListener("click", l), e.HTMLInputElement.addEventListener("focus", l), () => { t.forEach((e => e())) } })(e) : (f(e), ce(e), e.actions.initCalendar && e.actions.initCalendar(e), Ce(e))); return class extends u { constructor(e, t) { if (super(), i(this, "init", (() => we(this))), i(this, "update", (e => ((e, { year: t, month: n, dates: a, holidays: s, time: l } = {}) => { if (!e.isInit) throw new Error(S); e.input && !e.isInputInit && fe(e, !1), be(e, { year: t, month: n, dates: a, holidays: s, time: l }), e.actions.updateCalendar && e.actions.updateCalendar(e) })(this, e))), i(this, "destroy", (() => (e => { var t, n, a, s, l, i; if (!e.isInit) throw new Error(S); e.input ? (null == (n = null == (t = e.HTMLElement) ? void 0 : t.parentElement) || n.removeChild(e.HTMLElement), null == (s = null == (a = e.HTMLInputElement) ? void 0 : a.replaceWith) || s.call(a, e.HTMLOriginalElement), e.HTMLInputElement = void 0) : null == (i = null == (l = e.HTMLElement) ? void 0 : l.replaceWith) || i.call(l, e.HTMLOriginalElement), e.HTMLElement = e.HTMLOriginalElement, e.actions.destroyCalendar && e.actions.destroyCalendar(e) })(this))), i(this, "show", (() => { var e; (e = this).currentType ? (e.HTMLElement.classList.remove(e.CSSClasses.calendarHidden), e.actions.showCalendar && e.actions.showCalendar(e)) : e.HTMLElement.click() })), i(this, "hide", (() => { var e; (e = this).currentType && (e.HTMLElement.classList.add(e.CSSClasses.calendarHidden), e.actions.hideCalendar && e.actions.hideCalendar(e)) })), this.HTMLElement = "string" == typeof e ? document.querySelector(e) : e, !this.HTMLElement) throw new Error(p(e)); if (!t) return; const n = (e, t) => { Object.keys(t).forEach((a => { "object" != typeof e[a] || "object" != typeof t[a] || t[a] instanceof Date ? e[a] = t[a] : n(e[a], t[a]) })) }; n(this, t) } } }));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJjYWxlbmRhci92YW5pbGxhLWNhbGVuZGFyLm1pbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbmFtZTogdmFuaWxsYS1jYWxlbmRhci1wcm8gdjIuOS45IHwgdXJsOiBodHRwczovL2dpdGh1Yi5jb20vdXZhcm92LWZyb250ZW5kL3ZhbmlsbGEtY2FsZW5kYXItcHJvICovXG4hZnVuY3Rpb24gKGUsIHQpIHsgXCJvYmplY3RcIiA9PSB0eXBlb2YgZXhwb3J0cyAmJiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBtb2R1bGUgPyBtb2R1bGUuZXhwb3J0cyA9IHQoKSA6IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZGVmaW5lICYmIGRlZmluZS5hbWQgPyBkZWZpbmUodCkgOiAoZSA9IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIGdsb2JhbFRoaXMgPyBnbG9iYWxUaGlzIDogZSB8fCBzZWxmKS5WYW5pbGxhQ2FsZW5kYXIgPSB0KCkgfSh0aGlzLCAoZnVuY3Rpb24gKCkgeyBcInVzZSBzdHJpY3RcIjsgdmFyIGUgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIHQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLCBuID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgYSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUsIHMgPSAodCwgbiwgYSkgPT4gbiBpbiB0ID8gZSh0LCBuLCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlOiBhIH0pIDogdFtuXSA9IGEsIGwgPSAoZSwgbCkgPT4geyBmb3IgKHZhciBpIGluIGwgfHwgKGwgPSB7fSkpIG4uY2FsbChsLCBpKSAmJiBzKGUsIGksIGxbaV0pOyBpZiAodCkgZm9yICh2YXIgaSBvZiB0KGwpKSBhLmNhbGwobCwgaSkgJiYgcyhlLCBpLCBsW2ldKTsgcmV0dXJuIGUgfSwgaSA9IChlLCB0LCBuKSA9PiAocyhlLCBcInN5bWJvbFwiICE9IHR5cGVvZiB0ID8gdCArIFwiXCIgOiB0LCBuKSwgbik7IGNvbnN0IHIgPSB7IGNhbGVuZGFyOiBcInZhbmlsbGEtY2FsZW5kYXJcIiwgY2FsZW5kYXJEZWZhdWx0OiBcInZhbmlsbGEtY2FsZW5kYXJfZGVmYXVsdFwiLCBjYWxlbmRhck11bHRpcGxlOiBcInZhbmlsbGEtY2FsZW5kYXJfbXVsdGlwbGVcIiwgY2FsZW5kYXJNb250aDogXCJ2YW5pbGxhLWNhbGVuZGFyX21vbnRoXCIsIGNhbGVuZGFyWWVhcjogXCJ2YW5pbGxhLWNhbGVuZGFyX3llYXJcIiwgY2FsZW5kYXJIaWRkZW46IFwidmFuaWxsYS1jYWxlbmRhcl9oaWRkZW5cIiwgY2FsZW5kYXJUb0lucHV0OiBcInZhbmlsbGEtY2FsZW5kYXJfdG8taW5wdXRcIiwgY2FsZW5kYXJUb0lucHV0VG9wOiBcInZhbmlsbGEtY2FsZW5kYXJfdG8taW5wdXRfdG9wXCIsIGNhbGVuZGFyVG9JbnB1dEJvdHRvbTogXCJ2YW5pbGxhLWNhbGVuZGFyX3RvLWlucHV0X2JvdHRvbVwiLCBjb250cm9sczogXCJ2YW5pbGxhLWNhbGVuZGFyLWNvbnRyb2xzXCIsIGdyaWQ6IFwidmFuaWxsYS1jYWxlbmRhci1ncmlkXCIsIGdyaWREaXNhYmxlZDogXCJ2YW5pbGxhLWNhbGVuZGFyLWdyaWRfZGlzYWJsZWRcIiwgY29sdW1uOiBcInZhbmlsbGEtY2FsZW5kYXItY29sdW1uXCIsIGNvbHVtbk1vbnRoOiBcInZhbmlsbGEtY2FsZW5kYXItY29sdW1uX21vbnRoXCIsIGNvbHVtblllYXI6IFwidmFuaWxsYS1jYWxlbmRhci1jb2x1bW5feWVhclwiLCBoZWFkZXI6IFwidmFuaWxsYS1jYWxlbmRhci1oZWFkZXJcIiwgaGVhZGVyQ29udGVudDogXCJ2YW5pbGxhLWNhbGVuZGFyLWhlYWRlcl9fY29udGVudFwiLCBtb250aDogXCJ2YW5pbGxhLWNhbGVuZGFyLW1vbnRoXCIsIG1vbnRoRGlzYWJsZWQ6IFwidmFuaWxsYS1jYWxlbmRhci1tb250aF9kaXNhYmxlZFwiLCB5ZWFyOiBcInZhbmlsbGEtY2FsZW5kYXIteWVhclwiLCB5ZWFyRGlzYWJsZWQ6IFwidmFuaWxsYS1jYWxlbmRhci15ZWFyX2Rpc2FibGVkXCIsIGFycm93OiBcInZhbmlsbGEtY2FsZW5kYXItYXJyb3dcIiwgYXJyb3dQcmV2OiBcInZhbmlsbGEtY2FsZW5kYXItYXJyb3dfcHJldlwiLCBhcnJvd05leHQ6IFwidmFuaWxsYS1jYWxlbmRhci1hcnJvd19uZXh0XCIsIHdyYXBwZXI6IFwidmFuaWxsYS1jYWxlbmRhci13cmFwcGVyXCIsIGNvbnRlbnQ6IFwidmFuaWxsYS1jYWxlbmRhci1jb250ZW50XCIsIHdlZWs6IFwidmFuaWxsYS1jYWxlbmRhci13ZWVrXCIsIHdlZWtEYXk6IFwidmFuaWxsYS1jYWxlbmRhci13ZWVrX19kYXlcIiwgd2Vla0RheVdlZWtlbmQ6IFwidmFuaWxsYS1jYWxlbmRhci13ZWVrX19kYXlfd2Vla2VuZFwiLCBkYXlzOiBcInZhbmlsbGEtY2FsZW5kYXItZGF5c1wiLCBkYXlzU2VsZWN0aW5nOiBcInZhbmlsbGEtY2FsZW5kYXItZGF5c19zZWxlY3RpbmdcIiwgbW9udGhzOiBcInZhbmlsbGEtY2FsZW5kYXItbW9udGhzXCIsIG1vbnRoc1NlbGVjdGluZzogXCJ2YW5pbGxhLWNhbGVuZGFyLW1vbnRoc19zZWxlY3RpbmdcIiwgbW9udGhzTW9udGg6IFwidmFuaWxsYS1jYWxlbmRhci1tb250aHNfX21vbnRoXCIsIG1vbnRoc01vbnRoU2VsZWN0ZWQ6IFwidmFuaWxsYS1jYWxlbmRhci1tb250aHNfX21vbnRoX3NlbGVjdGVkXCIsIG1vbnRoc01vbnRoRGlzYWJsZWQ6IFwidmFuaWxsYS1jYWxlbmRhci1tb250aHNfX21vbnRoX2Rpc2FibGVkXCIsIHllYXJzOiBcInZhbmlsbGEtY2FsZW5kYXIteWVhcnNcIiwgeWVhcnNTZWxlY3Rpbmc6IFwidmFuaWxsYS1jYWxlbmRhci15ZWFyc19zZWxlY3RpbmdcIiwgeWVhcnNZZWFyOiBcInZhbmlsbGEtY2FsZW5kYXIteWVhcnNfX3llYXJcIiwgeWVhcnNZZWFyU2VsZWN0ZWQ6IFwidmFuaWxsYS1jYWxlbmRhci15ZWFyc19feWVhcl9zZWxlY3RlZFwiLCB5ZWFyc1llYXJEaXNhYmxlZDogXCJ2YW5pbGxhLWNhbGVuZGFyLXllYXJzX195ZWFyX2Rpc2FibGVkXCIsIHRpbWU6IFwidmFuaWxsYS1jYWxlbmRhci10aW1lXCIsIHRpbWVDb250ZW50OiBcInZhbmlsbGEtY2FsZW5kYXItdGltZV9fY29udGVudFwiLCB0aW1lSG91cnM6IFwidmFuaWxsYS1jYWxlbmRhci10aW1lX19ob3Vyc1wiLCB0aW1lTWludXRlczogXCJ2YW5pbGxhLWNhbGVuZGFyLXRpbWVfX21pbnV0ZXNcIiwgdGltZUtlZXBpbmc6IFwidmFuaWxsYS1jYWxlbmRhci10aW1lX19rZWVwaW5nXCIsIHRpbWVSYW5nZXM6IFwidmFuaWxsYS1jYWxlbmRhci10aW1lX19yYW5nZXNcIiwgdGltZVJhbmdlOiBcInZhbmlsbGEtY2FsZW5kYXItdGltZV9fcmFuZ2VcIiwgZGF5OiBcInZhbmlsbGEtY2FsZW5kYXItZGF5XCIsIGRheUhvdmVyRmlyc3Q6IFwidmFuaWxsYS1jYWxlbmRhci1kYXlfaG92ZXItZmlyc3RcIiwgZGF5SG92ZXJMYXN0OiBcInZhbmlsbGEtY2FsZW5kYXItZGF5X2hvdmVyLWxhc3RcIiwgZGF5SG92ZXJJbnRlcm1lZGlhdGU6IFwidmFuaWxsYS1jYWxlbmRhci1kYXlfaG92ZXItaW50ZXJtZWRpYXRlXCIsIGRheVNlbGVjdGVkRmlyc3Q6IFwidmFuaWxsYS1jYWxlbmRhci1kYXlfc2VsZWN0ZWQtZmlyc3RcIiwgZGF5U2VsZWN0ZWRMYXN0OiBcInZhbmlsbGEtY2FsZW5kYXItZGF5X3NlbGVjdGVkLWxhc3RcIiwgZGF5U2VsZWN0ZWRJbnRlcm1lZGlhdGU6IFwidmFuaWxsYS1jYWxlbmRhci1kYXlfc2VsZWN0ZWQtaW50ZXJtZWRpYXRlXCIsIGRheVBvcHVwOiBcInZhbmlsbGEtY2FsZW5kYXItZGF5X19wb3B1cFwiLCBkYXlCdG46IFwidmFuaWxsYS1jYWxlbmRhci1kYXlfX2J0blwiLCBkYXlCdG5QcmV2OiBcInZhbmlsbGEtY2FsZW5kYXItZGF5X19idG5fcHJldlwiLCBkYXlCdG5OZXh0OiBcInZhbmlsbGEtY2FsZW5kYXItZGF5X19idG5fbmV4dFwiLCBkYXlCdG5Ub2RheTogXCJ2YW5pbGxhLWNhbGVuZGFyLWRheV9fYnRuX3RvZGF5XCIsIGRheUJ0blNlbGVjdGVkOiBcInZhbmlsbGEtY2FsZW5kYXItZGF5X19idG5fc2VsZWN0ZWRcIiwgZGF5QnRuSG92ZXI6IFwidmFuaWxsYS1jYWxlbmRhci1kYXlfX2J0bl9ob3ZlclwiLCBkYXlCdG5EaXNhYmxlZDogXCJ2YW5pbGxhLWNhbGVuZGFyLWRheV9fYnRuX2Rpc2FibGVkXCIsIGRheUJ0bldlZWtlbmQ6IFwidmFuaWxsYS1jYWxlbmRhci1kYXlfX2J0bl93ZWVrZW5kXCIsIGRheUJ0bkhvbGlkYXk6IFwidmFuaWxsYS1jYWxlbmRhci1kYXlfX2J0bl9ob2xpZGF5XCIsIHdlZWtOdW1iZXJzOiBcInZhbmlsbGEtY2FsZW5kYXItd2Vlay1udW1iZXJzXCIsIHdlZWtOdW1iZXJzVGl0bGU6IFwidmFuaWxsYS1jYWxlbmRhci13ZWVrLW51bWJlcnNfX3RpdGxlXCIsIHdlZWtOdW1iZXJzQ29udGVudDogXCJ2YW5pbGxhLWNhbGVuZGFyLXdlZWstbnVtYmVyc19fY29udGVudFwiLCB3ZWVrTnVtYmVyOiBcInZhbmlsbGEtY2FsZW5kYXItd2Vlay1udW1iZXJcIiwgaXNGb2N1czogXCJ2YW5pbGxhLWNhbGVuZGFyLWlzLWZvY3VzXCIgfSwgZCA9IGUgPT4gYDxkaXYgY2xhc3M9XCIke2UuY29udHJvbHN9XCI+PCNBcnJvd1ByZXYgLz48I0Fycm93TmV4dCAvPjwvZGl2PjxkaXYgY2xhc3M9XCIke2UuZ3JpZH1cIj48I011bHRpcGxlPjxkaXYgY2xhc3M9XCIke2UuY29sdW1ufVwiPjxkaXYgY2xhc3M9XCIke2UuaGVhZGVyfVwiPjxkaXYgY2xhc3M9XCIke2UuaGVhZGVyQ29udGVudH1cIj48I01vbnRoIC8+PCNZZWFyIC8+PC9kaXY+PC9kaXY+PGRpdiBjbGFzcz1cIiR7ZS53cmFwcGVyfVwiPjwjV2Vla051bWJlcnMgLz48ZGl2IGNsYXNzPVwiJHtlLmNvbnRlbnR9XCI+PCNXZWVrIC8+PCNEYXlzIC8+PC9kaXY+PC9kaXY+PC9kaXY+PCMvTXVsdGlwbGU+PC9kaXY+PCNDb250cm9sVGltZSAvPmAsIG8gPSBlID0+IGA8ZGl2IGNsYXNzPVwiJHtlLmhlYWRlcn1cIj48ZGl2IGNsYXNzPVwiJHtlLmhlYWRlckNvbnRlbnR9XCI+PCNNb250aCAvPjwjWWVhciAvPjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9XCIke2Uud3JhcHBlcn1cIj48ZGl2IGNsYXNzPVwiJHtlLmNvbnRlbnR9XCI+PCNNb250aHMgLz48L2Rpdj48L2Rpdj5gLCBjID0gZSA9PiBgPGRpdiBjbGFzcz1cIiR7ZS5oZWFkZXJ9XCI+PCNBcnJvd1ByZXYgLz48ZGl2IGNsYXNzPVwiJHtlLmhlYWRlckNvbnRlbnR9XCI+PCNNb250aCAvPjwjWWVhciAvPjwvZGl2PjwjQXJyb3dOZXh0IC8+PC9kaXY+PGRpdiBjbGFzcz1cIiR7ZS53cmFwcGVyfVwiPjxkaXYgY2xhc3M9XCIke2UuY29udGVudH1cIj48I1llYXJzIC8+PC9kaXY+PC9kaXY+YDsgY2xhc3MgdSB7IGNvbnN0cnVjdG9yKCkgeyB2YXIgZTsgaSh0aGlzLCBcImlzSW5pdFwiLCAhMSksIGkodGhpcywgXCJpc0lucHV0SW5pdFwiLCAhMSksIGkodGhpcywgXCJpbnB1dFwiLCAhMSksIGkodGhpcywgXCJ0eXBlXCIsIFwiZGVmYXVsdFwiKSwgaSh0aGlzLCBcIm1vbnRoc1wiLCAyKSwgaSh0aGlzLCBcImp1bXBNb250aHNcIiwgMSksIGkodGhpcywgXCJqdW1wVG9TZWxlY3RlZERhdGVcIiwgITEpLCBpKHRoaXMsIFwidG9nZ2xlU2VsZWN0ZWRcIiwgITApLCBpKHRoaXMsIFwiZGF0ZVwiLCB7IG1pbjogXCIxOTcwLTAxLTAxXCIsIG1heDogXCIyNDcwLTEyLTMxXCIsIHRvZGF5OiBuZXcgRGF0ZSB9KSwgaSh0aGlzLCBcInNldHRpbmdzXCIsIHsgbGFuZzogXCJlblwiLCBpc284NjAxOiAhMCwgcmFuZ2U6IHsgbWluOiB2b2lkIDAsIG1heDogdm9pZCAwLCBkaXNhYmxlUGFzdDogITEsIGRpc2FibGVHYXBzOiAhMSwgZWRnZXNPbmx5OiAhMSwgZGlzYWJsZUFsbERheXM6ICExLCBkaXNhYmxlV2Vla2RheTogdm9pZCAwLCBkaXNhYmxlZDogdm9pZCAwLCBlbmFibGVkOiB2b2lkIDAgfSwgc2VsZWN0aW9uOiB7IGRheTogXCJzaW5nbGVcIiwgbW9udGg6ICEwLCB5ZWFyOiAhMCwgdGltZTogITEsIGNvbnRyb2xUaW1lOiBcImFsbFwiLCBzdGVwSG91cnM6IDEsIHN0ZXBNaW51dGVzOiAxLCBjYW5jZWxhYmxlRGF5OiAhMCB9LCBzZWxlY3RlZDogeyBkYXRlczogdm9pZCAwLCBtb250aDogdm9pZCAwLCB5ZWFyOiB2b2lkIDAsIGhvbGlkYXlzOiB2b2lkIDAsIHRpbWU6IHZvaWQgMCB9LCB2aXNpYmlsaXR5OiB7IHRoZW1lOiBcInN5c3RlbVwiLCB0aGVtZURldGVjdDogXCJodG1sW2RhdGEtdGhlbWVdXCIsIG1vbnRoU2hvcnQ6ICEwLCB3ZWVrTnVtYmVyczogITEsIHdlZWtlbmQ6ICEwLCB0b2RheTogITAsIGRpc2FibGVkOiAhMSwgZGF5c091dHNpZGU6ICEwLCBwb3NpdGlvblRvSW5wdXQ6IFwibGVmdFwiIH0gfSksIGkodGhpcywgXCJsb2NhbGVcIiwgeyBtb250aHM6IFtdLCB3ZWVrZGF5OiBbXSB9KSwgaSh0aGlzLCBcInNhbml0aXplclwiLCAoZSA9PiBlKSksIGkodGhpcywgXCJhY3Rpb25zXCIsIHsgY2xpY2tEYXk6IG51bGwsIGNsaWNrV2Vla051bWJlcjogbnVsbCwgY2xpY2tNb250aDogbnVsbCwgY2xpY2tZZWFyOiBudWxsLCBjbGlja0Fycm93OiBudWxsLCBjaGFuZ2VUaW1lOiBudWxsLCBjaGFuZ2VUb0lucHV0OiBudWxsLCBnZXREYXlzOiBudWxsLCBnZXRNb250aHM6IG51bGwsIGdldFllYXJzOiBudWxsLCBpbml0Q2FsZW5kYXI6IG51bGwsIHVwZGF0ZUNhbGVuZGFyOiBudWxsLCBkZXN0cm95Q2FsZW5kYXI6IG51bGwsIHNob3dDYWxlbmRhcjogbnVsbCwgaGlkZUNhbGVuZGFyOiBudWxsIH0pLCBpKHRoaXMsIFwicG9wdXBzXCIsIHt9KSwgaSh0aGlzLCBcIkNTU0NsYXNzZXNcIiwgbCh7fSwgcikpLCBpKHRoaXMsIFwiRE9NVGVtcGxhdGVzXCIsIHsgZGVmYXVsdDogKGUgPSB0aGlzLkNTU0NsYXNzZXMsIGA8ZGl2IGNsYXNzPVwiJHtlLmhlYWRlcn1cIj48I0Fycm93UHJldiAvPjxkaXYgY2xhc3M9XCIke2UuaGVhZGVyQ29udGVudH1cIj48I01vbnRoIC8+PCNZZWFyIC8+PC9kaXY+PCNBcnJvd05leHQgLz48L2Rpdj48ZGl2IGNsYXNzPVwiJHtlLndyYXBwZXJ9XCI+PCNXZWVrTnVtYmVycyAvPjxkaXYgY2xhc3M9XCIke2UuY29udGVudH1cIj48I1dlZWsgLz48I0RheXMgLz48L2Rpdj48L2Rpdj48I0NvbnRyb2xUaW1lIC8+YCksIG11bHRpcGxlOiBkKHRoaXMuQ1NTQ2xhc3NlcyksIG1vbnRoOiBvKHRoaXMuQ1NTQ2xhc3NlcyksIHllYXI6IGModGhpcy5DU1NDbGFzc2VzKSB9KSwgaSh0aGlzLCBcIkhUTUxFbGVtZW50XCIpLCBpKHRoaXMsIFwiSFRNTE9yaWdpbmFsRWxlbWVudFwiKSwgaSh0aGlzLCBcIkhUTUxJbnB1dEVsZW1lbnRcIiksIGkodGhpcywgXCJyYW5nZU1pblwiKSwgaSh0aGlzLCBcInJhbmdlTWF4XCIpLCBpKHRoaXMsIFwicmFuZ2VEaXNhYmxlZFwiKSwgaSh0aGlzLCBcInJhbmdlRW5hYmxlZFwiKSwgaSh0aGlzLCBcInNlbGVjdGVkRGF0ZXNcIiksIGkodGhpcywgXCJzZWxlY3RlZEhvbGlkYXlzXCIpLCBpKHRoaXMsIFwic2VsZWN0ZWRNb250aFwiKSwgaSh0aGlzLCBcInNlbGVjdGVkWWVhclwiKSwgaSh0aGlzLCBcInNlbGVjdGVkSG91cnNcIiksIGkodGhpcywgXCJzZWxlY3RlZE1pbnV0ZXNcIiksIGkodGhpcywgXCJzZWxlY3RlZEtlZXBpbmdcIiksIGkodGhpcywgXCJzZWxlY3RlZFRpbWVcIiksIGkodGhpcywgXCJjdXJyZW50VHlwZVwiKSwgaSh0aGlzLCBcImNvcnJlY3RNb250aHNcIiksIGkodGhpcywgXCJ2aWV3WWVhclwiKSwgaSh0aGlzLCBcImRhdGVNaW5cIiksIGkodGhpcywgXCJkYXRlTWF4XCIpIH0gfSBjb25zdCBtID0gZSA9PiBgJHtlLmdldEZ1bGxZZWFyKCl9LSR7U3RyaW5nKGUuZ2V0TW9udGgoKSArIDEpLnBhZFN0YXJ0KDIsIFwiMFwiKX0tJHtTdHJpbmcoZS5nZXREYXRlKCkpLnBhZFN0YXJ0KDIsIFwiMFwiKX1gLCBnID0gZSA9PiBuZXcgRGF0ZShgJHtlfVQwMDowMDowMGApLCBoID0gZSA9PiBlLnJlZHVjZSgoKGUsIHQpID0+IHsgaWYgKHQgaW5zdGFuY2VvZiBEYXRlIHx8IFwibnVtYmVyXCIgPT0gdHlwZW9mIHQpIHsgY29uc3QgbiA9IHQgaW5zdGFuY2VvZiBEYXRlID8gdCA6IG5ldyBEYXRlKHQpOyBlLnB1c2gobi50b0lTT1N0cmluZygpLnN1YnN0cmluZygwLCAxMCkpIH0gZWxzZSB0Lm1hdGNoKC9eKFxcZHs0fS1cXGR7Mn0tXFxkezJ9KSQvZykgPyBlLnB1c2godCkgOiB0LnJlcGxhY2UoLyhcXGR7NH0tXFxkezJ9LVxcZHsyfSkuKj8oXFxkezR9LVxcZHsyfS1cXGR7Mn0pL2csICgodCwgbiwgYSkgPT4geyBjb25zdCBzID0gZyhuKSwgbCA9IGcoYSksIGkgPSBuZXcgRGF0ZShzLmdldFRpbWUoKSk7IGZvciAoOyBpIDw9IGw7IGkuc2V0RGF0ZShpLmdldERhdGUoKSArIDEpKWUucHVzaChtKGkpKTsgcmV0dXJuIHQgfSkpOyByZXR1cm4gZSB9KSwgW10pLCB5ID0gKCkgPT4geyBjb25zdCBlID0gbmV3IERhdGU7IHJldHVybiBuZXcgRGF0ZShlLmdldFRpbWUoKSAtIDZlNCAqIGUuZ2V0VGltZXpvbmVPZmZzZXQoKSkudG9JU09TdHJpbmcoKS5zdWJzdHJpbmcoMCwgMTApIH0sIHYgPSBlID0+IGUgPyB7IDA6IFwiMTJcIiwgMTM6IFwiMDFcIiwgMTQ6IFwiMDJcIiwgMTU6IFwiMDNcIiwgMTY6IFwiMDRcIiwgMTc6IFwiMDVcIiwgMTg6IFwiMDZcIiwgMTk6IFwiMDdcIiwgMjA6IFwiMDhcIiwgMjE6IFwiMDlcIiwgMjI6IFwiMTBcIiwgMjM6IFwiMTFcIiB9W051bWJlcihlKV0gfHwgU3RyaW5nKGUpIDogXCJcIiwgcCA9IGUgPT4gYCR7ZX0gaXMgbm90IGZvdW5kLCBjaGVjayB0aGUgZmlyc3QgYXJndW1lbnQgcGFzc2VkIHRvIG5ldyBWYW5pbGxhQ2FsZW5kYXIuYCwgUyA9ICdUaGUgY2FsZW5kYXIgaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkLCBwbGVhc2UgaW5pdGlhbGl6ZSBpdCB1c2luZyB0aGUgXCJpbml0KClcIiBtZXRob2QgZmlyc3QuJywgTSA9ICdZb3Ugc3BlY2lmaWVkIFwiZGVmaW5lXCIgZm9yIFwic2V0dGluZ3MubGFuZ1wiIGJ1dCBkaWQgbm90IHByb3ZpZGUgdGhlIHJlcXVpcmVkIHZhbHVlcyBmb3IgXCJsb2NhbGUud2Vla2RheVwiIG9yIFwibG9jYWxlLm1vbnRoc1wiLicsIEMgPSAnSW5jb3JyZWN0IG5hbWUgb2YgdGhlbWUgaW4gXCJzZXR0aW5ncy52aXNpYmlsaXR5LnRoZW1lXCIuJywgYiA9IFwiVGhlIHZhbHVlIG9mIHRoZSB0aW1lIHByb3BlcnR5IGNhbiBiZTogZmFsc2UsIHRydWUsIDEyIG9yIDI0LlwiLCBmID0gZSA9PiB7IGUuY3VycmVudFR5cGUgPSBlLnR5cGUsIChlID0+IHsgdmFyIHQ7IGlmIChlLmp1bXBUb1NlbGVjdGVkRGF0ZSAmJiAobnVsbCA9PSAodCA9IGUuc2V0dGluZ3Muc2VsZWN0ZWQuZGF0ZXMpID8gdm9pZCAwIDogdC5sZW5ndGgpICYmIHZvaWQgMCA9PT0gZS5zZXR0aW5ncy5zZWxlY3RlZC5tb250aCAmJiB2b2lkIDAgPT09IGUuc2V0dGluZ3Muc2VsZWN0ZWQueWVhcikgeyBjb25zdCB0ID0gZyhoKGUuc2V0dGluZ3Muc2VsZWN0ZWQuZGF0ZXMpWzBdKTsgZS5zZXR0aW5ncy5zZWxlY3RlZC5tb250aCA9IHQuZ2V0TW9udGgoKSwgZS5zZXR0aW5ncy5zZWxlY3RlZC55ZWFyID0gdC5nZXRGdWxsWWVhcigpIH0gY29uc3QgbiA9IHZvaWQgMCAhPT0gZS5zZXR0aW5ncy5zZWxlY3RlZC5tb250aCAmJiBOdW1iZXIoZS5zZXR0aW5ncy5zZWxlY3RlZC5tb250aCkgPj0gMCAmJiBOdW1iZXIoZS5zZXR0aW5ncy5zZWxlY3RlZC5tb250aCkgPCAxMiwgYSA9IHZvaWQgMCAhPT0gZS5zZXR0aW5ncy5zZWxlY3RlZC55ZWFyICYmIE51bWJlcihlLnNldHRpbmdzLnNlbGVjdGVkLnllYXIpID49IDAgJiYgTnVtYmVyKGUuc2V0dGluZ3Muc2VsZWN0ZWQueWVhcikgPD0gOTk5OTsgZS5zZWxlY3RlZE1vbnRoID0gbiA/IE51bWJlcihlLnNldHRpbmdzLnNlbGVjdGVkLm1vbnRoKSA6IGUuZGF0ZS50b2RheS5nZXRNb250aCgpLCBlLnNlbGVjdGVkWWVhciA9IGEgPyBOdW1iZXIoZS5zZXR0aW5ncy5zZWxlY3RlZC55ZWFyKSA6IGUuZGF0ZS50b2RheS5nZXRGdWxsWWVhcigpLCBlLnZpZXdZZWFyID0gZS5zZWxlY3RlZFllYXIgfSkoZSksIChlID0+IHsgdmFyIHQsIG4sIGE7IFwidG9kYXlcIiA9PT0gZS5kYXRlLm1pbiAmJiAoZS5kYXRlLm1pbiA9IHkoKSksIFwidG9kYXlcIiA9PT0gZS5kYXRlLm1heCAmJiAoZS5kYXRlLm1heCA9IHkoKSksIFwidG9kYXlcIiA9PT0gZS5zZXR0aW5ncy5yYW5nZS5taW4gJiYgKGUuc2V0dGluZ3MucmFuZ2UubWluID0geSgpKSwgXCJ0b2RheVwiID09PSBlLnNldHRpbmdzLnJhbmdlLm1heCAmJiAoZS5zZXR0aW5ncy5yYW5nZS5tYXggPSB5KCkpLCBlLnNldHRpbmdzLnJhbmdlLm1pbiA9IGUuc2V0dGluZ3MucmFuZ2UubWluID8gZyhlLmRhdGUubWluKSA+PSBnKGUuc2V0dGluZ3MucmFuZ2UubWluKSA/IGUuZGF0ZS5taW4gOiBlLnNldHRpbmdzLnJhbmdlLm1pbiA6IGUuZGF0ZS5taW4sIGUuc2V0dGluZ3MucmFuZ2UubWF4ID0gZS5zZXR0aW5ncy5yYW5nZS5tYXggPyBnKGUuZGF0ZS5tYXgpIDw9IGcoZS5zZXR0aW5ncy5yYW5nZS5tYXgpID8gZS5kYXRlLm1heCA6IGUuc2V0dGluZ3MucmFuZ2UubWF4IDogZS5kYXRlLm1heDsgY29uc3QgcyA9IGUuc2V0dGluZ3MucmFuZ2UuZGlzYWJsZVBhc3QgJiYgIWUuc2V0dGluZ3MucmFuZ2UuZGlzYWJsZUFsbERheXMgJiYgZyhlLnNldHRpbmdzLnJhbmdlLm1pbikgPCBlLmRhdGUudG9kYXk7IGUucmFuZ2VNaW4gPSBzIHx8IGUuc2V0dGluZ3MucmFuZ2UuZGlzYWJsZUFsbERheXMgPyBtKGUuZGF0ZS50b2RheSkgOiBlLnNldHRpbmdzLnJhbmdlLm1pbiwgZS5yYW5nZU1heCA9IGUuc2V0dGluZ3MucmFuZ2UuZGlzYWJsZUFsbERheXMgPyBtKGUuZGF0ZS50b2RheSkgOiBlLnNldHRpbmdzLnJhbmdlLm1heCwgZS5yYW5nZURpc2FibGVkID0gZS5zZXR0aW5ncy5yYW5nZS5kaXNhYmxlZCAmJiAhZS5zZXR0aW5ncy5yYW5nZS5kaXNhYmxlQWxsRGF5cyA/IGgoZS5zZXR0aW5ncy5yYW5nZS5kaXNhYmxlZCkgOiBlLnNldHRpbmdzLnJhbmdlLmRpc2FibGVBbGxEYXlzID8gW2UucmFuZ2VNaW5dIDogW10sIGUucmFuZ2VEaXNhYmxlZC5sZW5ndGggPiAxICYmIGUucmFuZ2VEaXNhYmxlZC5zb3J0KCgoZSwgdCkgPT4gK25ldyBEYXRlKGUpIC0gK25ldyBEYXRlKHQpKSksIGUucmFuZ2VFbmFibGVkID0gZS5zZXR0aW5ncy5yYW5nZS5lbmFibGVkID8gaChlLnNldHRpbmdzLnJhbmdlLmVuYWJsZWQpIDogW10sIChudWxsID09ICh0ID0gZS5yYW5nZUVuYWJsZWQpID8gdm9pZCAwIDogdFswXSkgJiYgKG51bGwgPT0gKG4gPSBlLnJhbmdlRGlzYWJsZWQpID8gdm9pZCAwIDogblswXSkgJiYgKGUucmFuZ2VEaXNhYmxlZCA9IGUucmFuZ2VEaXNhYmxlZC5maWx0ZXIoKHQgPT4gIWUucmFuZ2VFbmFibGVkLmluY2x1ZGVzKHQpKSkpLCBlLnJhbmdlRW5hYmxlZC5sZW5ndGggPiAxICYmIGUucmFuZ2VFbmFibGVkLnNvcnQoKChlLCB0KSA9PiArbmV3IERhdGUoZSkgLSArbmV3IERhdGUodCkpKSwgKG51bGwgPT0gKGEgPSBlLnJhbmdlRW5hYmxlZCkgPyB2b2lkIDAgOiBhWzBdKSAmJiBlLnNldHRpbmdzLnJhbmdlLmRpc2FibGVBbGxEYXlzICYmIChlLnJhbmdlTWluID0gZS5yYW5nZUVuYWJsZWRbMF0sIGUucmFuZ2VNYXggPSBlLnJhbmdlRW5hYmxlZFtlLnJhbmdlRW5hYmxlZC5sZW5ndGggLSAxXSkgfSkoZSksIChlID0+IHsgdmFyIHQsIG47IGUuc2VsZWN0ZWREYXRlcyA9IChudWxsID09ICh0ID0gZS5zZXR0aW5ncy5zZWxlY3RlZC5kYXRlcykgPyB2b2lkIDAgOiB0WzBdKSA/IGgoZS5zZXR0aW5ncy5zZWxlY3RlZC5kYXRlcykgOiBbXSwgZS5zZWxlY3RlZEhvbGlkYXlzID0gKG51bGwgPT0gKG4gPSBlLnNldHRpbmdzLnNlbGVjdGVkLmhvbGlkYXlzKSA/IHZvaWQgMCA6IG5bMF0pID8gaChlLnNldHRpbmdzLnNlbGVjdGVkLmhvbGlkYXlzKSA6IFtdIH0pKGUpLCAoZSA9PiB7IGUuZGF0ZU1pbiA9IGUuc2V0dGluZ3MudmlzaWJpbGl0eS5kaXNhYmxlZCA/IGcoZS5kYXRlLm1pbikgOiBnKGUucmFuZ2VNaW4pLCBlLmRhdGVNYXggPSBlLnNldHRpbmdzLnZpc2liaWxpdHkuZGlzYWJsZWQgPyBnKGUuZGF0ZS5tYXgpIDogZyhlLnJhbmdlTWF4KSB9KShlKSwgKGUgPT4geyBjb25zdCB0ID0gITAgPT09IGUuc2V0dGluZ3Muc2VsZWN0aW9uLnRpbWUgfHwgMTIgPT09IGUuc2V0dGluZ3Muc2VsZWN0aW9uLnRpbWU7IGlmICh0IHx8IDI0ID09PSBlLnNldHRpbmdzLnNlbGVjdGlvbi50aW1lKSB7IGxldCBuID0gITE7IGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlLnNldHRpbmdzLnNlbGVjdGVkLnRpbWUpIHsgY29uc3QgYSA9IHQgPyAvXihbMC05XXwwWzEtOV18MVswLTJdKTooWzAtNV1bMC05XSl8KEFNfFBNKS9nIDogL14oWzAtMV0/WzAtOV18MlswLTNdKTooWzAtNV1bMC05XSkvZzsgZS5zZXR0aW5ncy5zZWxlY3RlZC50aW1lLnJlcGxhY2UoYSwgKChhLCBzLCBsLCBpKSA9PiAocyAmJiBsICYmIChuID0gITAsIGUuc2VsZWN0ZWRIb3VycyA9IHMsIGUuc2VsZWN0ZWRNaW51dGVzID0gbCksIGkgJiYgdCA/IGUuc2VsZWN0ZWRLZWVwaW5nID0gaSA6IHQgJiYgKGUuc2VsZWN0ZWRLZWVwaW5nID0gXCJBTVwiKSwgXCJcIikpKSB9ICFuICYmIHQgPyAoZS5zZWxlY3RlZEhvdXJzID0gdihTdHJpbmcoZS5kYXRlLnRvZGF5LmdldEhvdXJzKCkpKSwgZS5zZWxlY3RlZE1pbnV0ZXMgPSBTdHJpbmcoZS5kYXRlLnRvZGF5LmdldE1pbnV0ZXMoKSksIGUuc2VsZWN0ZWRLZWVwaW5nID0gTnVtYmVyKGUuZGF0ZS50b2RheS5nZXRIb3VycygpKSA+PSAxMiA/IFwiUE1cIiA6IFwiQU1cIikgOiBuIHx8IChlLnNlbGVjdGVkSG91cnMgPSBTdHJpbmcoZS5kYXRlLnRvZGF5LmdldEhvdXJzKCkpLCBlLnNlbGVjdGVkTWludXRlcyA9IFN0cmluZyhlLmRhdGUudG9kYXkuZ2V0TWludXRlcygpKSksIGUuc2VsZWN0ZWRIb3VycyA9IE51bWJlcihlLnNlbGVjdGVkSG91cnMpIDwgMTAgPyBgMCR7TnVtYmVyKGUuc2VsZWN0ZWRIb3Vycyl9YCA6IGAke2Uuc2VsZWN0ZWRIb3Vyc31gLCBlLnNlbGVjdGVkTWludXRlcyA9IE51bWJlcihlLnNlbGVjdGVkTWludXRlcykgPCAxMCA/IGAwJHtOdW1iZXIoZS5zZWxlY3RlZE1pbnV0ZXMpfWAgOiBgJHtlLnNlbGVjdGVkTWludXRlc31gLCBlLnNlbGVjdGVkVGltZSA9IGAke2Uuc2VsZWN0ZWRIb3Vyc306JHtlLnNlbGVjdGVkTWludXRlc30ke2Uuc2VsZWN0ZWRLZWVwaW5nID8gYCAke2Uuc2VsZWN0ZWRLZWVwaW5nfWAgOiBcIlwifWAgfSBlbHNlIGlmIChlLnNldHRpbmdzLnNlbGVjdGlvbi50aW1lKSB0aHJvdyBuZXcgRXJyb3IoYikgfSkoZSksIChlID0+IHsgZS5jb3JyZWN0TW9udGhzID0gXCJtdWx0aXBsZVwiID09PSBlLnR5cGUgPyAxID09PSBlLm1vbnRocyA/IDIgOiBlLm1vbnRocyA+IDEyID8gMTIgOiBlLm1vbnRocyA6IDEgfSkoZSkgfSwgdyA9ICh7IGFycm93UHJldjogZSwgYXJyb3dOZXh0OiB0LCBpc1ByZXZIaWRkZW46IG4sIGlzTmV4dEhpZGRlbjogYSB9KSA9PiB7IGUuc3R5bGUudmlzaWJpbGl0eSA9IG4gPyBcImhpZGRlblwiIDogXCJcIiwgdC5zdHlsZS52aXNpYmlsaXR5ID0gYSA/IFwiaGlkZGVuXCIgOiBcIlwiIH0sIEQgPSBlID0+IHsgdmFyIHQsIG47IGlmIChcIm1vbnRoXCIgPT09IGUuY3VycmVudFR5cGUpIHJldHVybjsgY29uc3QgYSA9IG51bGwgPT0gKHQgPSBlLkhUTUxFbGVtZW50KSA/IHZvaWQgMCA6IHQucXVlcnlTZWxlY3RvcihgLiR7ZS5DU1NDbGFzc2VzLmFycm93UHJldn1gKSwgcyA9IG51bGwgPT0gKG4gPSBlLkhUTUxFbGVtZW50KSA/IHZvaWQgMCA6IG4ucXVlcnlTZWxlY3RvcihgLiR7ZS5DU1NDbGFzc2VzLmFycm93TmV4dH1gKTsgaWYgKCFhIHx8ICFzKSByZXR1cm47ICh7IGRlZmF1bHQ6ICgpID0+IHsgY29uc3QgdCA9IGcobShuZXcgRGF0ZShlLnNlbGVjdGVkWWVhciwgZS5zZWxlY3RlZE1vbnRoLCAxKSkpLCBuID0gbmV3IERhdGUodC5nZXRUaW1lKCkpLCBsID0gbmV3IERhdGUodC5nZXRUaW1lKCkpOyBuLnNldE1vbnRoKG4uZ2V0TW9udGgoKSAtIGUuanVtcE1vbnRocyksIGwuc2V0TW9udGgobC5nZXRNb250aCgpICsgZS5qdW1wTW9udGhzKSwgZS5zZXR0aW5ncy5zZWxlY3Rpb24ueWVhciB8fCAoZS5kYXRlTWluLnNldEZ1bGxZZWFyKHQuZ2V0RnVsbFllYXIoKSksIGUuZGF0ZU1heC5zZXRGdWxsWWVhcih0LmdldEZ1bGxZZWFyKCkpKTsgY29uc3QgaSA9ICFlLnNldHRpbmdzLnNlbGVjdGlvbi5tb250aCB8fCBuLmdldEZ1bGxZZWFyKCkgPCBlLmRhdGVNaW4uZ2V0RnVsbFllYXIoKSB8fCBuLmdldEZ1bGxZZWFyKCkgPT09IGUuZGF0ZU1pbi5nZXRGdWxsWWVhcigpICYmIG4uZ2V0TW9udGgoKSA8IGUuZGF0ZU1pbi5nZXRNb250aCgpLCByID0gIWUuc2V0dGluZ3Muc2VsZWN0aW9uLm1vbnRoIHx8IGwuZ2V0RnVsbFllYXIoKSA+IGUuZGF0ZU1heC5nZXRGdWxsWWVhcigpIHx8IGwuZ2V0RnVsbFllYXIoKSA9PT0gZS5kYXRlTWF4LmdldEZ1bGxZZWFyKCkgJiYgbC5nZXRNb250aCgpID4gZS5kYXRlTWF4LmdldE1vbnRoKCk7IHcoeyBhcnJvd1ByZXY6IGEsIGFycm93TmV4dDogcywgaXNQcmV2SGlkZGVuOiBpLCBpc05leHRIaWRkZW46IHIgfSkgfSwgeWVhcjogKCkgPT4geyB3KHsgYXJyb3dQcmV2OiBhLCBhcnJvd05leHQ6IHMsIGlzUHJldkhpZGRlbjogZS5kYXRlTWluLmdldEZ1bGxZZWFyKCkgJiYgZS52aWV3WWVhciAtIDcgPD0gZS5kYXRlTWluLmdldEZ1bGxZZWFyKCksIGlzTmV4dEhpZGRlbjogZS5kYXRlTWF4LmdldEZ1bGxZZWFyKCkgJiYgZS52aWV3WWVhciArIDcgPj0gZS5kYXRlTWF4LmdldEZ1bGxZZWFyKCkgfSkgfSB9KVtcIm11bHRpcGxlXCIgPT09IGUuY3VycmVudFR5cGUgPyBcImRlZmF1bHRcIiA6IGUuY3VycmVudFR5cGVdKCkgfSwgVCA9IChlLCB0KSA9PiB7IGlmICghZSkgcmV0dXJuIG51bGw7IGNvbnN0IG4gPSBnKGUpLCBhID0gdCA/IG4uZ2V0RGF5KCkgfHwgNyA6IG4uZ2V0RGF5KCk7IG4uc2V0RGF0ZShuLmdldERhdGUoKSArIDQgLSBhKTsgY29uc3QgcyA9IG5ldyBEYXRlKG4uZ2V0RnVsbFllYXIoKSwgMCwgMSksIGwgPSBNYXRoLmNlaWwoKCgrbiAtICtzKSAvIDg2NGU1ICsgMSkgLyA3KTsgcmV0dXJuIHsgeWVhcjogbi5nZXRGdWxsWWVhcigpLCB3ZWVrOiBsIH0gfTsgZnVuY3Rpb24gTChlKSB7IGlmICghZSB8fCAhZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QpIHJldHVybiB7IHRvcDogMCwgYm90dG9tOiAwLCBsZWZ0OiAwLCByaWdodDogMCB9OyBjb25zdCB0ID0gZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgbiA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDsgcmV0dXJuIHsgYm90dG9tOiB0LmJvdHRvbSwgcmlnaHQ6IHQucmlnaHQsIHRvcDogdC50b3AgKyB3aW5kb3cuc2Nyb2xsWSAtIG4uY2xpZW50VG9wLCBsZWZ0OiB0LmxlZnQgKyB3aW5kb3cuc2Nyb2xsWCAtIG4uY2xpZW50TGVmdCB9IH0gZnVuY3Rpb24gRSgpIHsgcmV0dXJuIHsgdnc6IE1hdGgubWF4KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCB8fCAwLCB3aW5kb3cuaW5uZXJXaWR0aCB8fCAwKSwgdmg6IE1hdGgubWF4KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgfHwgMCwgd2luZG93LmlubmVySGVpZ2h0IHx8IDApIH0gfSBmdW5jdGlvbiAkKGUpIHsgY29uc3QgeyB0b3A6IHQsIGxlZnQ6IG4gfSA9IHsgbGVmdDogd2luZG93LnNjcm9sbFggfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgfHwgMCwgdG9wOiB3aW5kb3cuc2Nyb2xsWSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8IDAgfSwgeyB0b3A6IGEsIGxlZnQ6IHMgfSA9IEwoZSksIHsgdmg6IGwsIHZ3OiBpIH0gPSBFKCksIHIgPSBhIC0gdCwgZCA9IHMgLSBuOyByZXR1cm4geyB0b3A6IHIsIGJvdHRvbTogbCAtIChyICsgZS5jbGllbnRIZWlnaHQpLCBsZWZ0OiBkLCByaWdodDogaSAtIChkICsgZS5jbGllbnRXaWR0aCkgfSB9IGZ1bmN0aW9uIEgoZSwgdCwgbiA9IDUpIHsgY29uc3QgYSA9IHsgdG9wOiAhMCwgYm90dG9tOiAhMCwgbGVmdDogITAsIHJpZ2h0OiAhMCB9LCBzID0gW107IGlmICghdCB8fCAhZSkgcmV0dXJuIHsgY2FuU2hvdzogYSwgcGFyZW50UG9zaXRpb25zOiBzIH07IGNvbnN0IHsgYm90dG9tOiBsLCB0b3A6IGkgfSA9ICQoZSksIHsgdG9wOiByLCBsZWZ0OiBkIH0gPSBMKGUpLCB7IGhlaWdodDogbywgd2lkdGg6IGMgfSA9IHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHsgdmg6IHUsIHZ3OiBtIH0gPSBFKCksIGcgPSBtIC8gMiwgaCA9IHUgLyAyOyByZXR1cm4gW3sgY29uZGl0aW9uOiByIDwgaCwgcG9zaXRpb246IFwidG9wXCIgfSwgeyBjb25kaXRpb246IHIgPiBoLCBwb3NpdGlvbjogXCJib3R0b21cIiB9LCB7IGNvbmRpdGlvbjogZCA8IGcsIHBvc2l0aW9uOiBcImxlZnRcIiB9LCB7IGNvbmRpdGlvbjogZCA+IGcsIHBvc2l0aW9uOiBcInJpZ2h0XCIgfV0uZm9yRWFjaCgoKHsgY29uZGl0aW9uOiBlLCBwb3NpdGlvbjogdCB9KSA9PiB7IGUgJiYgcy5wdXNoKHQpIH0pKSwgT2JqZWN0LmFzc2lnbihhLCB7IHRvcDogbyA8PSBpIC0gbiwgYm90dG9tOiBvIDw9IGwgLSBuLCBsZWZ0OiBjIDw9IGQsIHJpZ2h0OiBjIDw9IG0gLSBkIH0pLCB7IGNhblNob3c6IGEsIHBhcmVudFBvc2l0aW9uczogcyB9IH0gY29uc3QgayA9IChlLCB0LCBuLCBhKSA9PiB7IGlmIChlKSB7IGNvbnN0IHMgPSBcImF1dG9cIiA9PT0gbiA/IGZ1bmN0aW9uIChlLCB0KSB7IGNvbnN0IG4gPSBcImxlZnRcIjsgaWYgKCF0IHx8ICFlKSByZXR1cm4gbjsgY29uc3QgeyBjYW5TaG93OiBhLCBwYXJlbnRQb3NpdGlvbnM6IHMgfSA9IEgoZSwgdCksIGwgPSBhLmxlZnQgJiYgYS5yaWdodDsgcmV0dXJuIChsICYmIGEuYm90dG9tID8gXCJjZW50ZXJcIiA6IGwgJiYgYS50b3AgPyBbXCJ0b3BcIiwgXCJjZW50ZXJcIl0gOiBBcnJheS5pc0FycmF5KHMpID8gW1wiYm90dG9tXCIgPT09IHNbMF0gPyBcInRvcFwiIDogXCJib3R0b21cIiwgLi4ucy5zbGljZSgxKV0gOiBzKSB8fCBuIH0oZSwgdCkgOiBuLCBsID0geyB0b3A6IC10Lm9mZnNldEhlaWdodCwgYm90dG9tOiBlLm9mZnNldEhlaWdodCwgbGVmdDogMCwgY2VudGVyOiBlLm9mZnNldFdpZHRoIC8gMiAtIHQub2Zmc2V0V2lkdGggLyAyLCByaWdodDogZS5vZmZzZXRXaWR0aCAtIHQub2Zmc2V0V2lkdGggfSwgaSA9IEFycmF5LmlzQXJyYXkocykgPyBzWzBdIDogXCJib3R0b21cIiwgciA9IEFycmF5LmlzQXJyYXkocykgPyBzWzFdIDogczsgXCJib3R0b21cIiA9PT0gaSA/ICh0LmNsYXNzTGlzdC5yZW1vdmUoYS5jYWxlbmRhclRvSW5wdXRUb3ApLCB0LmNsYXNzTGlzdC5hZGQoYS5jYWxlbmRhclRvSW5wdXRCb3R0b20pKSA6ICh0LmNsYXNzTGlzdC5yZW1vdmUoYS5jYWxlbmRhclRvSW5wdXRCb3R0b20pLCB0LmNsYXNzTGlzdC5hZGQoYS5jYWxlbmRhclRvSW5wdXRUb3ApKTsgY29uc3QgeyB0b3A6IGQsIGxlZnQ6IG8gfSA9IEwoZSksIGMgPSBkICsgbFtpXSwgdSA9IG8gKyBsW3JdOyBPYmplY3QuYXNzaWduKHQuc3R5bGUsIHsgbGVmdDogYCR7dX1weGAsIHRvcDogYCR7Y31weGAgfSkgfSB9LCB4ID0gKGUsIHQpID0+IHsgdmFyIG47IGUucG9wdXBzICYmIChudWxsID09IChuID0gT2JqZWN0LmVudHJpZXMoZS5wb3B1cHMpKSB8fCBuLmZvckVhY2goKChbbiwgYV0pID0+ICgoZSwgdCwgbiwgYSkgPT4geyBjb25zdCBzID0gZS5DU1NDbGFzc2VzLmRheVBvcHVwLCBsID0gYS5xdWVyeVNlbGVjdG9yKGBbZGF0YS1jYWxlbmRhci1kYXk9XCIke3R9XCJdYCk7IGlmIChsICYmICgobnVsbCA9PSBuID8gdm9pZCAwIDogbi5tb2RpZmllcikgJiYgbC5jbGFzc0xpc3QuYWRkKC4uLm4ubW9kaWZpZXIudHJpbSgpLnNwbGl0KFwiIFwiKSksIG51bGwgPT0gbiA/IHZvaWQgMCA6IG4uaHRtbCkpIHsgY29uc3QgdCA9IGwucGFyZW50RWxlbWVudCwgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7IGEuY2xhc3NOYW1lID0gcywgYS5pbm5lckhUTUwgPSBlLnNhbml0aXplcihuLmh0bWwpLCB0LmFwcGVuZENoaWxkKGEpLCBzZXRUaW1lb3V0KCgoKSA9PiB7IGlmIChhKSB7IGNvbnN0IHsgY2FuU2hvdzogZSB9ID0gSCh0LCBhKSwgbiA9IDU7IGxldCBzID0gdC5vZmZzZXRIZWlnaHQsIGwgPSAwOyBlLmJvdHRvbSB8fCAocyA9IC1hLm9mZnNldEhlaWdodCAtIG4pLCBlLmxlZnQgJiYgIWUucmlnaHQgJiYgKGwgPSB0Lm9mZnNldFdpZHRoIC0gYS5vZmZzZXRXaWR0aCAvIDIpLCAhZS5sZWZ0ICYmIGUucmlnaHQgJiYgKGwgPSBhLm9mZnNldFdpZHRoIC8gMiksIE9iamVjdC5hc3NpZ24oYS5zdHlsZSwgeyBsZWZ0OiBgJHtsfXB4YCwgdG9wOiBgJHtzfXB4YCB9KSB9IH0pKSB9IH0pKGUsIG4sIGEsIHQpKSkpIH0sIFkgPSAoZSwgdCwgbiwgYSwgcykgPT4geyBjb25zdCBsID0gdFtuXS5xdWVyeVNlbGVjdG9yKGAuJHtlLkNTU0NsYXNzZXMuZGF5QnRufWApLCBpID0gVChudWxsID09IGwgPyB2b2lkIDAgOiBsLmRhdGFzZXQuY2FsZW5kYXJEYXksIGUuc2V0dGluZ3MuaXNvODYwMSk7IGlmICghaSkgcmV0dXJuOyBjb25zdCByID0gYS5jbG9uZU5vZGUoITApOyByLmlubmVyVGV4dCA9IFN0cmluZyhpLndlZWspLCByLmRhdGFzZXQuY2FsZW5kYXJZZWFyV2VlayA9IFN0cmluZyhpLnllYXIpLCBzLmFwcGVuZENoaWxkKHIpIH0sIF8gPSAoZSwgdCwgbiwgYSwgcywgbCwgaSwgcikgPT4geyBjb25zdCBkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTsgZC5jbGFzc05hbWUgPSBlLkNTU0NsYXNzZXMuZGF5OyBjb25zdCBvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTsgby5jbGFzc05hbWUgPSBgJHtlLkNTU0NsYXNzZXMuZGF5QnRufSR7ciA/IGAgJHtyfWAgOiBcIlwifWAsIG8udHlwZSA9IFwiYnV0dG9uXCIsIG8uaW5uZXJUZXh0ID0gU3RyaW5nKGEpLCBvLmRhdGFzZXQuY2FsZW5kYXJEYXkgPSBsOyBlLnNldHRpbmdzLnZpc2liaWxpdHkud2Vla051bWJlcnMgJiYgKCgpID0+IHsgY29uc3QgdCA9IFQobCwgZS5zZXR0aW5ncy5pc284NjAxKTsgdCAmJiAoby5kYXRhc2V0LmNhbGVuZGFyV2Vla051bWJlciA9IFN0cmluZyh0LndlZWspKSB9KSgpLCBpID8gZS5zZXR0aW5ncy52aXNpYmlsaXR5LmRheXNPdXRzaWRlICYmIGQuYXBwZW5kQ2hpbGQobykgOiBkLmFwcGVuZENoaWxkKG8pLCAoKGUsIHQsIG4pID0+IHsgdmFyIGEsIHMsIGwsIGksIHI7IGNvbnN0IGQgPSBudWxsID09IChhID0gZS5zZXR0aW5ncy5yYW5nZS5kaXNhYmxlV2Vla2RheSkgPyB2b2lkIDAgOiBhLmluY2x1ZGVzKG4pLCBvID0gZS5zZXR0aW5ncy5yYW5nZS5kaXNhYmxlQWxsRGF5cyAmJiAhIShudWxsID09IChzID0gZS5yYW5nZUVuYWJsZWQpID8gdm9pZCAwIDogc1swXSk7ICFkICYmICFvIHx8IChudWxsID09IChsID0gZS5yYW5nZUVuYWJsZWQpID8gdm9pZCAwIDogbC5pbmNsdWRlcyh0KSkgfHwgKG51bGwgPT0gKGkgPSBlLnJhbmdlRGlzYWJsZWQpID8gdm9pZCAwIDogaS5pbmNsdWRlcyh0KSkgfHwgKGUucmFuZ2VEaXNhYmxlZC5wdXNoKHQpLCBudWxsID09IChyID0gZS5yYW5nZURpc2FibGVkKSB8fCByLnNvcnQoKChlLCB0KSA9PiArbmV3IERhdGUoZSkgLSArbmV3IERhdGUodCkpKSkgfSkoZSwgbCwgcyksICgoZSwgdCwgbiwgYSwgcywgbCwgaSkgPT4geyB2YXIgciwgZCwgbzsgaWYgKChnKGUucmFuZ2VNaW4pID4gZyhsKSB8fCBnKGUucmFuZ2VNYXgpIDwgZyhsKSB8fCAobnVsbCA9PSAociA9IGUucmFuZ2VEaXNhYmxlZCkgPyB2b2lkIDAgOiByLmluY2x1ZGVzKGwpKSB8fCAhZS5zZXR0aW5ncy5zZWxlY3Rpb24ubW9udGggJiYgaSB8fCAhZS5zZXR0aW5ncy5zZWxlY3Rpb24ueWVhciAmJiBnKGwpLmdldEZ1bGxZZWFyKCkgIT09IHQpICYmIChhLmNsYXNzTGlzdC5hZGQoZS5DU1NDbGFzc2VzLmRheUJ0bkRpc2FibGVkKSwgYS50YWJJbmRleCA9IC0xKSwgZS5zZXR0aW5ncy52aXNpYmlsaXR5LnRvZGF5ICYmIG0oZS5kYXRlLnRvZGF5KSA9PT0gbCAmJiBhLmNsYXNzTGlzdC5hZGQoZS5DU1NDbGFzc2VzLmRheUJ0blRvZGF5KSwgIWUuc2V0dGluZ3MudmlzaWJpbGl0eS53ZWVrZW5kIHx8IDAgIT09IHMgJiYgNiAhPT0gcyB8fCBhLmNsYXNzTGlzdC5hZGQoZS5DU1NDbGFzc2VzLmRheUJ0bldlZWtlbmQpLCAobnVsbCA9PSAoZCA9IGUuc2VsZWN0ZWRIb2xpZGF5cykgPyB2b2lkIDAgOiBkLmluY2x1ZGVzKGwpKSAmJiBhLmNsYXNzTGlzdC5hZGQoZS5DU1NDbGFzc2VzLmRheUJ0bkhvbGlkYXkpLCAobnVsbCA9PSAobyA9IGUuc2VsZWN0ZWREYXRlcykgPyB2b2lkIDAgOiBvLmluY2x1ZGVzKGwpKSAmJiAoYS5jbGFzc0xpc3QuYWRkKGUuQ1NTQ2xhc3Nlcy5kYXlCdG5TZWxlY3RlZCksIGUuc2VsZWN0ZWREYXRlcy5sZW5ndGggPiAxICYmIFwibXVsdGlwbGUtcmFuZ2VkXCIgPT09IGUuc2V0dGluZ3Muc2VsZWN0aW9uLmRheSAmJiAoZS5zZWxlY3RlZERhdGVzWzBdID09PSBsICYmIG4uY2xhc3NMaXN0LmFkZChlLkNTU0NsYXNzZXMuZGF5U2VsZWN0ZWRGaXJzdCksIGUuc2VsZWN0ZWREYXRlc1tlLnNlbGVjdGVkRGF0ZXMubGVuZ3RoIC0gMV0gPT09IGwgJiYgbi5jbGFzc0xpc3QuYWRkKGUuQ1NTQ2xhc3Nlcy5kYXlTZWxlY3RlZExhc3QpLCBlLnNlbGVjdGVkRGF0ZXNbMF0gIT09IGwgJiYgZS5zZWxlY3RlZERhdGVzW2Uuc2VsZWN0ZWREYXRlcy5sZW5ndGggLSAxXSAhPT0gbCAmJiBuLmNsYXNzTGlzdC5hZGQoZS5DU1NDbGFzc2VzLmRheVNlbGVjdGVkSW50ZXJtZWRpYXRlKSkpLCBlLnNldHRpbmdzLnJhbmdlLmVkZ2VzT25seSAmJiBlLnNlbGVjdGVkRGF0ZXMubGVuZ3RoID4gMSAmJiBcIm11bHRpcGxlLXJhbmdlZFwiID09PSBlLnNldHRpbmdzLnNlbGVjdGlvbi5kYXkpIHsgY29uc3QgdCA9ICtuZXcgRGF0ZShlLnNlbGVjdGVkRGF0ZXNbMF0pLCBzID0gK25ldyBEYXRlKGUuc2VsZWN0ZWREYXRlc1tlLnNlbGVjdGVkRGF0ZXMubGVuZ3RoIC0gMV0pLCBpID0gK25ldyBEYXRlKGwpOyBpID4gdCAmJiBpIDwgcyAmJiAoYS5jbGFzc0xpc3QuYWRkKGUuQ1NTQ2xhc3Nlcy5kYXlCdG5TZWxlY3RlZCksIG4uY2xhc3NMaXN0LmFkZChlLkNTU0NsYXNzZXMuZGF5U2VsZWN0ZWRJbnRlcm1lZGlhdGUpKSB9IH0pKGUsIHQsIGQsIG8sIHMsIGwsIGkpLCBuLmFwcGVuZENoaWxkKGQpLCBlLmFjdGlvbnMuZ2V0RGF5cyAmJiBlLmFjdGlvbnMuZ2V0RGF5cyhhLCBsLCBkLCBvLCBlKSB9LCBOID0gZSA9PiB7IGNvbnN0IHQgPSBlLkhUTUxFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYC4ke2UuQ1NTQ2xhc3Nlcy5kYXlzfWApLCBuID0gZS5IVE1MRWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKGAuJHtlLkNTU0NsYXNzZXMud2Vla051bWJlcnN9YCksIGEgPSBuZXcgRGF0ZShlLnNlbGVjdGVkWWVhciwgZS5zZWxlY3RlZE1vbnRoLCAxKTsgdC5mb3JFYWNoKCgodCwgcykgPT4geyBjb25zdCBsID0gbmV3IERhdGUoYSk7IGwuc2V0TW9udGgobC5nZXRNb250aCgpICsgcyk7IGNvbnN0IGkgPSBsLmdldE1vbnRoKCksIHIgPSBsLmdldEZ1bGxZZWFyKCksIGQgPSBuZXcgRGF0ZShyLCBpLCAxKSwgbyA9IG5ldyBEYXRlKHIsIGkgKyAxLCAwKS5nZXREYXRlKCksIGMgPSBlLnNldHRpbmdzLmlzbzg2MDEgPyAoMCAhPT0gZC5nZXREYXkoKSA/IGQuZ2V0RGF5KCkgOiA3KSAtIDEgOiBkLmdldERheSgpOyBlLnNldHRpbmdzLnNlbGVjdGlvbi5kYXkgJiYgdC5jbGFzc0xpc3QuYWRkKGUuQ1NTQ2xhc3Nlcy5kYXlzU2VsZWN0aW5nKSwgdC50ZXh0Q29udGVudCA9IFwiXCIsICgoZSwgdCwgbiwgYSwgcykgPT4geyBsZXQgbCA9IG5ldyBEYXRlKG4sIGEsIDApLmdldERhdGUoKSAtIChzIC0gMSk7IGNvbnN0IGkgPSAwID09PSBhID8gbiAtIDEgOiBuLCByID0gMCA9PT0gYSA/IDEyIDogYSA8IDEwID8gYDAke2F9YCA6IGE7IGZvciAobGV0IGEgPSBzOyBhID4gMDsgYS0tLCBsKyspIHsgY29uc3QgYSA9IGAke2l9LSR7cn0tJHtsfWAsIHMgPSBnKGEpLmdldERheSgpOyBfKGUsIG4sIHQsIGwsIHMsIGEsICEwLCBlLkNTU0NsYXNzZXMuZGF5QnRuUHJldikgfSB9KShlLCB0LCByLCBpLCBjKSwgKChlLCB0LCBuLCBhLCBzKSA9PiB7IGZvciAobGV0IGwgPSAxOyBsIDw9IG47IGwrKykgeyBjb25zdCBuID0gbmV3IERhdGUoYSwgcywgbCksIGkgPSBtKG4pLCByID0gbi5nZXREYXkoKTsgXyhlLCBhLCB0LCBsLCByLCBpLCAhMSwgbnVsbCkgfSB9KShlLCB0LCBvLCByLCBpKSwgKChlLCB0LCBuLCBhLCBzLCBsKSA9PiB7IGNvbnN0IGkgPSBsICsgbiwgciA9IDcgKiBNYXRoLmNlaWwoaSAvIDcpIC0gaSwgZCA9IHMgKyAxID09PSAxMiA/IGEgKyAxIDogYSwgbyA9IHMgKyAxID09PSAxMiA/IFwiMDFcIiA6IHMgKyAyIDwgMTAgPyBgMCR7cyArIDJ9YCA6IHMgKyAyOyBmb3IgKGxldCBuID0gMTsgbiA8PSByOyBuKyspIHsgY29uc3QgcyA9IGAke2R9LSR7b30tJHtuIDwgMTAgPyBgMCR7bn1gIDogU3RyaW5nKG4pfWAsIGwgPSBnKHMpLmdldERheSgpOyBfKGUsIGEsIHQsIG4sIGwsIHMsICEwLCBlLkNTU0NsYXNzZXMuZGF5QnRuTmV4dCkgfSB9KShlLCB0LCBvLCByLCBpLCBjKSwgKChlLCB0LCBuLCBhLCBzKSA9PiB7IGlmICghZS5zZXR0aW5ncy52aXNpYmlsaXR5LndlZWtOdW1iZXJzKSByZXR1cm47IGEudGV4dENvbnRlbnQgPSBcIlwiOyBjb25zdCBsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJcIik7IGwuY2xhc3NOYW1lID0gZS5DU1NDbGFzc2VzLndlZWtOdW1iZXJzVGl0bGUsIGwuaW5uZXJUZXh0ID0gXCIjXCIsIGEuYXBwZW5kQ2hpbGQobCk7IGNvbnN0IGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpOyBpLmNsYXNzTmFtZSA9IGUuQ1NTQ2xhc3Nlcy53ZWVrTnVtYmVyc0NvbnRlbnQsIGEuYXBwZW5kQ2hpbGQoaSk7IGNvbnN0IHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpOyByLnR5cGUgPSBcImJ1dHRvblwiLCByLmNsYXNzTmFtZSA9IGUuQ1NTQ2xhc3Nlcy53ZWVrTnVtYmVyOyBjb25zdCBkID0gcy5xdWVyeVNlbGVjdG9yQWxsKGAuJHtlLkNTU0NsYXNzZXMuZGF5fWApLCBvID0gTWF0aC5jZWlsKCh0ICsgbikgLyA3KTsgZm9yIChsZXQgdCA9IDA7IHQgPCBvOyB0KyspWShlLCBkLCAwID09PSB0ID8gNiA6IDcgKiB0LCByLCBpKSB9KShlLCBjLCBvLCBuW3NdLCB0KSwgeChlLCB0KSB9KSkgfSwgQSA9IGUgPT4geyB2YXIgdCwgbjsgY29uc3QgYSA9IG51bGwgPT0gKHQgPSBlLkhUTUxFbGVtZW50KSA/IHZvaWQgMCA6IHQucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLWNhbGVuZGFyLXNlbGVjdGVkLW1vbnRoXVwiKSwgcyA9IG51bGwgPT0gKG4gPSBlLkhUTUxFbGVtZW50KSA/IHZvaWQgMCA6IG4ucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLWNhbGVuZGFyLXNlbGVjdGVkLXllYXJdXCIpOyBpZiAoIShudWxsID09IGEgPyB2b2lkIDAgOiBhWzBdKSAmJiAobnVsbCA9PSBzID8gdm9pZCAwIDogc1swXSkpIHJldHVybjsgY29uc3QgbCA9IG5ldyBEYXRlKGUuc2VsZWN0ZWRZZWFyLCBlLnNlbGVjdGVkTW9udGgsIDEpOyBudWxsID09IGEgfHwgYS5mb3JFYWNoKCgodCwgbikgPT4gKChlLCB0LCBuLCBhKSA9PiB7IGNvbnN0IHMgPSBuZXcgRGF0ZShhLnNldE1vbnRoKGUuc2VsZWN0ZWRNb250aCArIG4pKS5nZXRNb250aCgpLCBsID0gITEgPT09IGUuc2V0dGluZ3Muc2VsZWN0aW9uLm1vbnRoIHx8IFwib25seS1hcnJvd3NcIiA9PT0gZS5zZXR0aW5ncy5zZWxlY3Rpb24ubW9udGg7IHQudGFiSW5kZXggPSBsID8gLTEgOiAwLCB0LmNsYXNzTGlzdC50b2dnbGUoZS5DU1NDbGFzc2VzLm1vbnRoRGlzYWJsZWQsIGwpLCB0LnNldEF0dHJpYnV0ZShcImRhdGEtY2FsZW5kYXItc2VsZWN0ZWQtbW9udGhcIiwgU3RyaW5nKHMpKSwgdC5pbm5lclRleHQgPSBlLmxvY2FsZS5tb250aHNbc10gfSkoZSwgdCwgbiwgbCkpKSwgbnVsbCA9PSBzIHx8IHMuZm9yRWFjaCgoKHQsIG4pID0+ICgoZSwgdCwgbiwgYSkgPT4geyBjb25zdCBzID0gbmV3IERhdGUoYS5zZXRGdWxsWWVhcihlLnNlbGVjdGVkWWVhciwgZS5zZWxlY3RlZE1vbnRoICsgbikpLmdldEZ1bGxZZWFyKCksIGwgPSAhMSA9PT0gZS5zZXR0aW5ncy5zZWxlY3Rpb24ueWVhciB8fCBcIm9ubHktYXJyb3dzXCIgPT09IGUuc2V0dGluZ3Muc2VsZWN0aW9uLnllYXI7IHQudGFiSW5kZXggPSBsID8gLTEgOiAwLCB0LmNsYXNzTGlzdC50b2dnbGUoZS5DU1NDbGFzc2VzLnllYXJEaXNhYmxlZCwgbCksIHQuc2V0QXR0cmlidXRlKFwiZGF0YS1jYWxlbmRhci1zZWxlY3RlZC15ZWFyXCIsIFN0cmluZyhzKSksIHQuaW5uZXJUZXh0ID0gU3RyaW5nKHMpIH0pKGUsIHQsIG4sIGwpKSkgfSwgSSA9IChlLCB0KSA9PiB7IGNvbnN0IG4gPSBnKG0obmV3IERhdGUoZS5zZWxlY3RlZFllYXIsIGUuc2VsZWN0ZWRNb250aCwgMSkpKTsgKHsgcHJldjogKCkgPT4gbi5zZXRNb250aChuLmdldE1vbnRoKCkgLSBlLmp1bXBNb250aHMpLCBuZXh0OiAoKSA9PiBuLnNldE1vbnRoKG4uZ2V0TW9udGgoKSArIGUuanVtcE1vbnRocykgfSlbdF0oKSwgW2Uuc2VsZWN0ZWRNb250aCwgZS5zZWxlY3RlZFllYXJdID0gW24uZ2V0TW9udGgoKSwgbi5nZXRGdWxsWWVhcigpXSwgQShlKSwgRChlKSwgTihlKSB9LCBQID0gT2JqZWN0LmZyZWV6ZShPYmplY3QuZGVmaW5lUHJvcGVydHkoeyBfX3Byb3RvX186IG51bGwsIEFycm93TmV4dDogZSA9PiBgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCJjbGFzcz1cIiR7ZS5DU1NDbGFzc2VzLmFycm93fSAke2UuQ1NTQ2xhc3Nlcy5hcnJvd05leHR9XCJkYXRhLWNhbGVuZGFyLWFycm93PVwibmV4dFwiPjwvYnV0dG9uPmAsIEFycm93UHJldjogZSA9PiBgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCJjbGFzcz1cIiR7ZS5DU1NDbGFzc2VzLmFycm93fSAke2UuQ1NTQ2xhc3Nlcy5hcnJvd1ByZXZ9XCJkYXRhLWNhbGVuZGFyLWFycm93PVwicHJldlwiPjwvYnV0dG9uPmAsIENvbnRyb2xUaW1lOiBlID0+IGUuc2V0dGluZ3Muc2VsZWN0aW9uLnRpbWUgPyBgPGRpdiBjbGFzcz1cIiR7ZS5DU1NDbGFzc2VzLnRpbWV9XCI+PC9kaXY+YCA6IFwiXCIsIERheXM6IGUgPT4gYDxkaXYgY2xhc3M9XCIke2UuQ1NTQ2xhc3Nlcy5kYXlzfVwiPjwvZGl2PmAsIE1vbnRoOiBlID0+IGA8YnV0dG9uIHR5cGU9XCJidXR0b25cImNsYXNzPVwiJHtlLkNTU0NsYXNzZXMubW9udGh9XCJkYXRhLWNhbGVuZGFyLXNlbGVjdGVkLW1vbnRoPjwvYnV0dG9uPmAsIE1vbnRoczogZSA9PiBgPGRpdiBjbGFzcz1cIiR7ZS5DU1NDbGFzc2VzLm1vbnRoc31cIj48L2Rpdj5gLCBXZWVrOiBlID0+IGA8ZGl2IGNsYXNzPVwiJHtlLkNTU0NsYXNzZXMud2Vla31cIj48L2Rpdj5gLCBXZWVrTnVtYmVyczogZSA9PiBlLnNldHRpbmdzLnZpc2liaWxpdHkud2Vla051bWJlcnMgPyBgPGRpdiBjbGFzcz1cIiR7ZS5DU1NDbGFzc2VzLndlZWtOdW1iZXJzfVwiPjwvZGl2PmAgOiBcIlwiLCBZZWFyOiBlID0+IGA8YnV0dG9uIHR5cGU9XCJidXR0b25cImNsYXNzPVwiJHtlLkNTU0NsYXNzZXMueWVhcn1cImRhdGEtY2FsZW5kYXItc2VsZWN0ZWQteWVhcj48L2J1dHRvbj5gLCBZZWFyczogZSA9PiBgPGRpdiBjbGFzcz1cIiR7ZS5DU1NDbGFzc2VzLnllYXJzfVwiPjwvZGl2PmAgfSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKSwgRiA9IChlLCB0KSA9PiB0LnJlcGxhY2UoL1tcXG5cXHRdL2csIFwiXCIpLnJlcGxhY2UoLzwjKD8hXFwvP011bHRpcGxlKSguKj8pPi9nLCAoKHQsIG4pID0+IHsgY29uc3QgYSA9IChzID0gbi5yZXBsYWNlKC9bL1xcc1xcblxcdF0vZywgXCJcIiksIFBbc10pOyB2YXIgczsgY29uc3QgbCA9IGEgPyBhKGUpIDogXCJcIjsgcmV0dXJuIGUuc2FuaXRpemVyKGwpIH0pKS5yZXBsYWNlKC9bXFxuXFx0XS9nLCBcIlwiKSwgcSA9IChlLCB0KSA9PiB7IGNvbnN0IHsgSFRNTEVsZW1lbnQ6IG4sIENTU0NsYXNzZXM6IGEsIERPTVRlbXBsYXRlczogcywgdHlwZTogbCwgY3VycmVudFR5cGU6IGksIGNvcnJlY3RNb250aHM6IHIgfSA9IGUsIGQgPSAocywgbCkgPT4geyBpZiAoIXQpIHJldHVybjsgY29uc3QgaSA9IG4ucXVlcnlTZWxlY3RvcihgLiR7YS5jb250cm9sc31gKTsgaSAmJiBuLnJlbW92ZUNoaWxkKGkpOyBuLnF1ZXJ5U2VsZWN0b3IoYC4ke2EuZ3JpZH1gKS5jbGFzc0xpc3QuYWRkKGEuZ3JpZERpc2FibGVkKTsgY29uc3QgciA9IHQuY2xvc2VzdChgLiR7YS5jb2x1bW59YCk7IHIuY2xhc3NMaXN0LmFkZChzKSwgci5pbm5lckhUTUwgPSBGKGUsIGwpIH0sIG8gPSB7IGRlZmF1bHQ6ICgpID0+IHsgbi5jbGFzc0xpc3QuYWRkKGEuY2FsZW5kYXJEZWZhdWx0KSwgbi5jbGFzc0xpc3QucmVtb3ZlKGEuY2FsZW5kYXJNb250aCwgYS5jYWxlbmRhclllYXIpLCBuLmlubmVySFRNTCA9IEYoZSwgcy5kZWZhdWx0KSB9LCBtdWx0aXBsZTogKCkgPT4geyByICYmIChuLmNsYXNzTGlzdC5hZGQoYS5jYWxlbmRhck11bHRpcGxlKSwgbi5jbGFzc0xpc3QucmVtb3ZlKGEuY2FsZW5kYXJNb250aCwgYS5jYWxlbmRhclllYXIpLCBuLmlubmVySFRNTCA9ICgoZSwgdCkgPT4gdC5yZXBsYWNlKC88I011bHRpcGxlPiguKj8pPCNcXC9NdWx0aXBsZT4vZywgKCh0LCBuKSA9PiB7IGxldCBhID0gXCJcIjsgZm9yIChsZXQgdCA9IDA7IHQgPCBlLmNvcnJlY3RNb250aHM7IHQrKylhICs9IG47IHJldHVybiBlLnNhbml0aXplcihhKSB9KSkucmVwbGFjZSgvW1xcblxcdF0vZywgXCJcIikpKGUsIEYoZSwgcy5tdWx0aXBsZSkpKSB9LCBtb250aDogKCkgPT4geyBcIm11bHRpcGxlXCIgIT09IGwgPyAobi5jbGFzc0xpc3QuYWRkKGEuY2FsZW5kYXJNb250aCksIG4uY2xhc3NMaXN0LnJlbW92ZShhLmNhbGVuZGFyRGVmYXVsdCwgYS5jYWxlbmRhclllYXIpLCBuLmlubmVySFRNTCA9IEYoZSwgcy5tb250aCkpIDogZChhLmNvbHVtbk1vbnRoLCBzLm1vbnRoKSB9LCB5ZWFyOiAoKSA9PiB7IFwibXVsdGlwbGVcIiAhPT0gbCA/IChuLmNsYXNzTGlzdC5hZGQoYS5jYWxlbmRhclllYXIpLCBuLmNsYXNzTGlzdC5yZW1vdmUoYS5jYWxlbmRhckRlZmF1bHQsIGEuY2FsZW5kYXJNb250aCksIG4uaW5uZXJIVE1MID0gRihlLCBzLnllYXIpKSA6IGQoYS5jb2x1bW5ZZWFyLCBzLnllYXIpIH0gfTsgbi5jbGFzc0xpc3QuYWRkKGEuY2FsZW5kYXIpLCBvW2ldKCkgfSwgQiA9IChlLCB0LCBuLCBhLCBzKSA9PiB7IGNvbnN0IGwgPSB0LmNsb25lTm9kZSghMSk7IHJldHVybiBsLmNsYXNzTmFtZSA9IGAke2UuQ1NTQ2xhc3Nlcy55ZWFyc1llYXJ9JHtuID09PSBzID8gYCAke2UuQ1NTQ2xhc3Nlcy55ZWFyc1llYXJTZWxlY3RlZH1gIDogYSA/IGAgJHtlLkNTU0NsYXNzZXMueWVhcnNZZWFyRGlzYWJsZWR9YCA6IFwiXCJ9YCwgbC5kYXRhc2V0LmNhbGVuZGFyWWVhciA9IFN0cmluZyhzKSwgbC50aXRsZSA9IFN0cmluZyhzKSwgbC5pbm5lclRleHQgPSBTdHJpbmcocyksIGEgJiYgKGwudGFiSW5kZXggPSAtMSksIGwgfSwgVyA9IChlLCB0KSA9PiB7IGNvbnN0IG4gPSAobnVsbCA9PSB0ID8gdm9pZCAwIDogdC5kYXRhc2V0LmNhbGVuZGFyU2VsZWN0ZWRZZWFyKSA/IE51bWJlcihudWxsID09IHQgPyB2b2lkIDAgOiB0LmRhdGFzZXQuY2FsZW5kYXJTZWxlY3RlZFllYXIpIDogZS5zZWxlY3RlZFllYXI7IGUuY3VycmVudFR5cGUgPSBcInllYXJcIiwgcShlLCB0KSwgQShlKSwgRChlKTsgY29uc3QgYSA9IGUuSFRNTEVsZW1lbnQucXVlcnlTZWxlY3RvcihgLiR7ZS5DU1NDbGFzc2VzLnllYXJzfWApOyBpZiAoIWUuc2V0dGluZ3Muc2VsZWN0aW9uLnllYXIgfHwgIWEpIHJldHVybjsgYS5jbGFzc0xpc3QuYWRkKGUuQ1NTQ2xhc3Nlcy55ZWFyc1NlbGVjdGluZyk7IGNvbnN0IHMgPSBcIm11bHRpcGxlXCIgIT09IGUudHlwZSB8fCBlLnNlbGVjdGVkWWVhciA9PT0gbiA/IDAgOiAxLCBsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTsgbC50eXBlID0gXCJidXR0b25cIjsgZm9yIChsZXQgdCA9IGUudmlld1llYXIgLSA3OyB0IDwgZS52aWV3WWVhciArIDg7IHQrKykgeyBjb25zdCBpID0gdCA8IGUuZGF0ZU1pbi5nZXRGdWxsWWVhcigpICsgcyB8fCB0ID4gZS5kYXRlTWF4LmdldEZ1bGxZZWFyKCksIHIgPSBCKGUsIGwsIG4sIGksIHQpOyBhLmFwcGVuZENoaWxkKHIpLCBlLmFjdGlvbnMuZ2V0WWVhcnMgJiYgZS5hY3Rpb25zLmdldFllYXJzKHQsIHIsIGUpIH0gfSwgTyA9IGUgPT4gYCR7ZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKX0ke2Uuc3Vic3RyaW5nKDEsIGUubGVuZ3RoKX1gLnJlcGxhY2UoL1xcLi8sIFwiXCIpLCBqID0gKGUsIHQpID0+IHsgY29uc3QgbiA9IG5ldyBEYXRlKGAxOTc4LTAxLTAke3QgKyAxfVQwMDowMDowMC4wMDBaYCkudG9Mb2NhbGVTdHJpbmcoZS5zZXR0aW5ncy5sYW5nLCB7IHdlZWtkYXk6IFwic2hvcnRcIiwgdGltZVpvbmU6IFwiVVRDXCIgfSk7IGUubG9jYWxlLndlZWtkYXkucHVzaChPKG4pKSB9LCBLID0gKGUsIHQpID0+IHsgY29uc3QgbiA9IG5ldyBEYXRlKGAxOTc4LSR7dCArIDEgPD0gOSA/IGAwJHt0ICsgMX1gIDogdCArIDF9LTAxVDAwOjAwOjAwLjAwMFpgKS50b0xvY2FsZVN0cmluZyhlLnNldHRpbmdzLmxhbmcsIHsgbW9udGg6IFwibG9uZ1wiLCB0aW1lWm9uZTogXCJVVENcIiB9KTsgZS5sb2NhbGUubW9udGhzLnB1c2goTyhuKSkgfSwgeiA9IGUgPT4geyBpZiAoXCJtdWx0aXBsZVwiICE9PSBlLnR5cGUpIHJldHVybiAwOyBjb25zdCB0ID0gZS5IVE1MRWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKGAuJHtlLkNTU0NsYXNzZXMuY29sdW1ufWApLCBuID0gQXJyYXkuZnJvbSh0KS5maW5kSW5kZXgoKHQgPT4gdC5jbGFzc0xpc3QuY29udGFpbnMoYCR7ZS5DU1NDbGFzc2VzLmNvbHVtbk1vbnRofWApKSk7IHJldHVybiBuID4gMCA/IG4gOiAwIH0sIFIgPSAoZSwgdCwgbiwgYSwgcywgbCkgPT4geyBjb25zdCBpID0gdC5jbG9uZU5vZGUoITEpOyByZXR1cm4gaS5jbGFzc05hbWUgPSBgJHtlLkNTU0NsYXNzZXMubW9udGhzTW9udGh9JHtuID09PSBsID8gYCAke2UuQ1NTQ2xhc3Nlcy5tb250aHNNb250aFNlbGVjdGVkfWAgOiBzID8gYCAke2UuQ1NTQ2xhc3Nlcy5tb250aHNNb250aERpc2FibGVkfWAgOiBcIlwifWAsIGkudGl0bGUgPSBhLCBpLmlubmVyVGV4dCA9IGAke2Uuc2V0dGluZ3MudmlzaWJpbGl0eS5tb250aFNob3J0ID8gYS5zdWJzdHJpbmcoMCwgMykgOiBhfWAsIGkuZGF0YXNldC5jYWxlbmRhck1vbnRoID0gU3RyaW5nKGwpLCBzICYmIChpLnRhYkluZGV4ID0gLTEpLCBpIH0sIEcgPSAoZSwgdCkgPT4geyB2YXIgbiwgYTsgY29uc3QgcyA9IChudWxsID09IHQgPyB2b2lkIDAgOiB0LmRhdGFzZXQuY2FsZW5kYXJTZWxlY3RlZE1vbnRoKSA/IE51bWJlcih0LmRhdGFzZXQuY2FsZW5kYXJTZWxlY3RlZE1vbnRoKSA6IGUuc2VsZWN0ZWRNb250aCwgbCA9IG51bGwgPT0gKG4gPSBudWxsID09IHQgPyB2b2lkIDAgOiB0LmNsb3Nlc3QoYC4ke2UuQ1NTQ2xhc3Nlcy5jb2x1bW59YCkpID8gdm9pZCAwIDogbi5xdWVyeVNlbGVjdG9yKGAuJHtlLkNTU0NsYXNzZXMueWVhcn1gKSwgaSA9IGwgPyBOdW1iZXIobC5kYXRhc2V0LmNhbGVuZGFyU2VsZWN0ZWRZZWFyKSA6IGUuc2VsZWN0ZWRZZWFyOyBlLmN1cnJlbnRUeXBlID0gXCJtb250aFwiLCBxKGUsIHQpLCBBKGUpOyBjb25zdCByID0gbnVsbCA9PSAoYSA9IGUuSFRNTEVsZW1lbnQpID8gdm9pZCAwIDogYS5xdWVyeVNlbGVjdG9yKGAuJHtlLkNTU0NsYXNzZXMubW9udGhzfWApOyBpZiAoIWUuc2V0dGluZ3Muc2VsZWN0aW9uLm1vbnRoIHx8ICFyKSByZXR1cm47IHIuY2xhc3NMaXN0LmFkZChlLkNTU0NsYXNzZXMubW9udGhzU2VsZWN0aW5nKTsgY29uc3QgZCA9IGUuanVtcE1vbnRocyA+IDEgPyBlLmxvY2FsZS5tb250aHMubWFwKCgodCwgbikgPT4gcyAtIGUuanVtcE1vbnRocyAqIG4pKS5jb25jYXQoZS5sb2NhbGUubW9udGhzLm1hcCgoKHQsIG4pID0+IHMgKyBlLmp1bXBNb250aHMgKiBuKSkpLmZpbHRlcigoZSA9PiBlID49IDAgJiYgZSA8PSAxMikpIDogQXJyYXkuZnJvbShBcnJheSgxMikua2V5cygpKSwgbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7IG8udHlwZSA9IFwiYnV0dG9uXCI7IGZvciAobGV0IHQgPSAwOyB0IDwgMTI7IHQrKykgeyBjb25zdCBuID0gZS5sb2NhbGUubW9udGhzW3RdLCBhID0gdCA8IGUuZGF0ZU1pbi5nZXRNb250aCgpICsgeihlKSAmJiBpIDw9IGUuZGF0ZU1pbi5nZXRGdWxsWWVhcigpIHx8IHQgPiBlLmRhdGVNYXguZ2V0TW9udGgoKSArIHooZSkgJiYgaSA+PSBlLmRhdGVNYXguZ2V0RnVsbFllYXIoKSB8fCB0ICE9PSBzICYmICFkLmluY2x1ZGVzKHQpLCBsID0gUihlLCBvLCBzLCBuLCBhLCB0KTsgci5hcHBlbmRDaGlsZChsKSwgZS5hY3Rpb25zLmdldE1vbnRocyAmJiBlLmFjdGlvbnMuZ2V0TW9udGhzKHQsIGwsIGUpIH0gfSwgWiA9IChlLCB0KSA9PiBlICYmIHQgPyB7IDA6IHsgQU06IFwiMDBcIiwgUE06IFwiMTJcIiB9LCAxOiB7IEFNOiBcIjAxXCIsIFBNOiBcIjEzXCIgfSwgMjogeyBBTTogXCIwMlwiLCBQTTogXCIxNFwiIH0sIDM6IHsgQU06IFwiMDNcIiwgUE06IFwiMTVcIiB9LCA0OiB7IEFNOiBcIjA0XCIsIFBNOiBcIjE2XCIgfSwgNTogeyBBTTogXCIwNVwiLCBQTTogXCIxN1wiIH0sIDY6IHsgQU06IFwiMDZcIiwgUE06IFwiMThcIiB9LCA3OiB7IEFNOiBcIjA3XCIsIFBNOiBcIjE5XCIgfSwgODogeyBBTTogXCIwOFwiLCBQTTogXCIyMFwiIH0sIDk6IHsgQU06IFwiMDlcIiwgUE06IFwiMjFcIiB9LCAxMDogeyBBTTogXCIxMFwiLCBQTTogXCIyMlwiIH0sIDExOiB7IEFNOiBcIjExXCIsIFBNOiBcIjIzXCIgfSwgMTI6IHsgQU06IFwiMTJcIiwgUE06IFwiMTJcIiB9IH1bTnVtYmVyKGUpXVt0XSA6IFwiXCIsIFUgPSAoZSwgdCwgbikgPT4gZS5xdWVyeVNlbGVjdG9yKGAuJHt0fSR7biA/IGAgaW5wdXRbbmFtZT1cIiR7bn1cIl1gIDogXCJcIn1gKSwgViA9IChlLCB0LCBuKSA9PiB7IGUuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3ZlclwiLCAoKCkgPT4gdC5jbGFzc0xpc3QuYWRkKG4pKSksIGUuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3V0XCIsICgoKSA9PiB0LmNsYXNzTGlzdC5yZW1vdmUobikpKSB9LCBYID0gKGUsIHQsIG4sIGEpID0+IHsgKHsgaG91cnM6ICgpID0+IHsgZS5zZWxlY3RlZEhvdXJzID0gbiB9LCBtaW51dGVzOiAoKSA9PiB7IGUuc2VsZWN0ZWRNaW51dGVzID0gbiB9IH0pW2FdKCksIGUuc2VsZWN0ZWRUaW1lID0gYCR7ZS5zZWxlY3RlZEhvdXJzfToke2Uuc2VsZWN0ZWRNaW51dGVzfSR7ZS5zZWxlY3RlZEtlZXBpbmcgPyBgICR7ZS5zZWxlY3RlZEtlZXBpbmd9YCA6IFwiXCJ9YCwgZS5hY3Rpb25zLmNoYW5nZVRpbWUgJiYgZS5hY3Rpb25zLmNoYW5nZVRpbWUodCwgZSksIGUuaW5wdXQgJiYgZS5IVE1MSW5wdXRFbGVtZW50ICYmIGUuYWN0aW9ucy5jaGFuZ2VUb0lucHV0ICYmIGUuYWN0aW9ucy5jaGFuZ2VUb0lucHV0KHQsIGUpIH0sIEogPSAoZSwgdCwgbiwgYSwgcywgbCkgPT4geyB0LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCAodCA9PiB7IGNvbnN0IGkgPSB0LnRhcmdldCwgciA9IE51bWJlcihpLnZhbHVlKSwgZCA9IHIgPCAxMCA/IGAwJHtyfWAgOiBgJHtyfWA7IGlmIChcImhvdXJzXCIgIT09IHMgfHwgMTIgIT09IGwpIHJldHVybiBuLnZhbHVlID0gZCwgdm9pZCBYKGUsIHQsIGQsIHMpOyByIDwgbCAmJiByID4gMCA/IChuLnZhbHVlID0gZCwgZS5zZWxlY3RlZEtlZXBpbmcgPSBcIkFNXCIsIGEuaW5uZXJUZXh0ID0gZS5zZWxlY3RlZEtlZXBpbmcsIFgoZSwgdCwgZCwgcykpIDogKDAgPT09IHIgPyAoZS5zZWxlY3RlZEtlZXBpbmcgPSBcIkFNXCIsIGEuaW5uZXJUZXh0ID0gXCJBTVwiKSA6IChlLnNlbGVjdGVkS2VlcGluZyA9IFwiUE1cIiwgYS5pbm5lclRleHQgPSBcIlBNXCIpLCBuLnZhbHVlID0gdihpLnZhbHVlKSwgWChlLCB0LCB2KGkudmFsdWUpLCBzKSkgfSkpIH0sIFEgPSAoZSwgdCwgbiwgYSwgcywgbCkgPT4geyBuLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgKG4gPT4geyBjb25zdCBpID0gbi50YXJnZXQsIHIgPSBOdW1iZXIoaS52YWx1ZSksIGQgPSByIDwgMTAgPyBgMCR7cn1gIDogYCR7cn1gOyBcImhvdXJzXCIgPT09IHMgJiYgMTIgPT09IGwgPyBpLnZhbHVlICYmIHIgPD0gbCAmJiByID4gMCA/IChpLnZhbHVlID0gZCwgdC52YWx1ZSA9IFooZCwgZS5zZWxlY3RlZEtlZXBpbmcpLCBYKGUsIG4sIGQsIHMpKSA6IGkudmFsdWUgJiYgciA8IDI0ICYmIChyID4gbCB8fCAwID09PSByKSA/ICgwID09PSByID8gKGUuc2VsZWN0ZWRLZWVwaW5nID0gXCJBTVwiLCBhLmlubmVyVGV4dCA9IFwiQU1cIikgOiAoZS5zZWxlY3RlZEtlZXBpbmcgPSBcIlBNXCIsIGEuaW5uZXJUZXh0ID0gXCJQTVwiKSwgaS52YWx1ZSA9IHYoaS52YWx1ZSksIHQudmFsdWUgPSBkLCBYKGUsIG4sIHYoaS52YWx1ZSksIHMpKSA6IGkudmFsdWUgPSBlLnNlbGVjdGVkSG91cnMgOiBpLnZhbHVlICYmIHIgPD0gbCAmJiByID49IDAgPyAoaS52YWx1ZSA9IGQsIHQudmFsdWUgPSBkLCBYKGUsIG4sIGQsIHMpKSA6IFwiaG91cnNcIiA9PT0gcyA/IGkudmFsdWUgPSBlLnNlbGVjdGVkSG91cnMgOiBcIm1pbnV0ZXNcIiA9PT0gcyAmJiAoaS52YWx1ZSA9IGUuc2VsZWN0ZWRNaW51dGVzKSB9KSkgfSwgZWUgPSAoZSwgdCwgbikgPT4geyBjb25zdCBhID0gMjQgPT09IG4gPyAyMyA6IG4gfHwgMTIsIHMgPSBVKHQsIGUuQ1NTQ2xhc3Nlcy50aW1lUmFuZ2UsIFwiaG91cnNcIiksIGwgPSBVKHQsIGUuQ1NTQ2xhc3Nlcy50aW1lUmFuZ2UsIFwibWludXRlc1wiKSwgaSA9IFUodCwgZS5DU1NDbGFzc2VzLnRpbWVIb3VycywgXCJob3Vyc1wiKSwgciA9IFUodCwgZS5DU1NDbGFzc2VzLnRpbWVNaW51dGVzLCBcIm1pbnV0ZXNcIiksIGQgPSB0LnF1ZXJ5U2VsZWN0b3IoYC4ke2UuQ1NTQ2xhc3Nlcy50aW1lS2VlcGluZ31gKTsgVihzLCBpLCBlLkNTU0NsYXNzZXMuaXNGb2N1cyksIFYobCwgciwgZS5DU1NDbGFzc2VzLmlzRm9jdXMpLCBKKGUsIHMsIGksIGQsIFwiaG91cnNcIiwgYSksIEooZSwgbCwgciwgZCwgXCJtaW51dGVzXCIsIDApLCBRKGUsIHMsIGksIGQsIFwiaG91cnNcIiwgYSksIFEoZSwgbCwgciwgZCwgXCJtaW51dGVzXCIsIDU5KSwgZCAmJiAoKGUsIHQsIG4pID0+IHsgdC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKGEgPT4geyBlLnNlbGVjdGVkS2VlcGluZyA9IHQuaW5uZXJUZXh0LmluY2x1ZGVzKFwiQU1cIikgPyBcIlBNXCIgOiBcIkFNXCIsIHQuaW5uZXJUZXh0ID0gZS5zZWxlY3RlZEtlZXBpbmcsIG4udmFsdWUgPSBaKGUuc2VsZWN0ZWRIb3VycywgZS5zZWxlY3RlZEtlZXBpbmcpLCBYKGUsIGEsIGUuc2VsZWN0ZWRIb3VycywgXCJob3Vyc1wiKSB9KSkgfSkoZSwgZCwgcykgfSwgdGUgPSAoZSwgdCwgbiwgYSkgPT4gYDxsYWJlbCBjbGFzcz1cIiR7dH1cIj48aW5wdXQgdHlwZT1cInRleHRcIm5hbWU9XCIke2V9XCJtYXhsZW5ndGg9XCIyXCJ2YWx1ZT1cIiR7bn1cIiR7YSA/IFwiZGlzYWJsZWRcIiA6IFwiXCJ9PjwvbGFiZWw+YCwgbmUgPSAoZSwgdCwgbiwgYSwgcywgbCkgPT4gYDxsYWJlbCBjbGFzcz1cIiR7dH1cIj48aW5wdXQgdHlwZT1cInJhbmdlXCJuYW1lPVwiJHtlfVwibWluPVwiJHtufVwibWF4PVwiJHthfVwic3RlcD1cIiR7c31cInZhbHVlPVwiJHtsfVwiPjwvbGFiZWw+YCwgYWUgPSBlID0+IHsgY29uc3QgdCA9IFsuLi5lLmxvY2FsZS53ZWVrZGF5XTsgaWYgKCF0WzBdKSByZXR1cm47IGUuc2V0dGluZ3MuaXNvODYwMSAmJiB0LnB1c2godC5zaGlmdCgpKTsgZS5IVE1MRWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKGAuJHtlLkNTU0NsYXNzZXMud2Vla31gKS5mb3JFYWNoKChuID0+ICgoZSwgdCwgbikgPT4geyBjb25zdCBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJcIik7IHQudGV4dENvbnRlbnQgPSBcIlwiOyBmb3IgKGxldCBzID0gMDsgcyA8IG4ubGVuZ3RoOyBzKyspIHsgY29uc3QgbCA9IG5bc10sIGkgPSBhLmNsb25lTm9kZSghMCk7IGkuY2xhc3NOYW1lID0gYCR7ZS5DU1NDbGFzc2VzLndlZWtEYXl9YCwgaS5jbGFzc05hbWUgPSBgJHtlLkNTU0NsYXNzZXMud2Vla0RheX0ke2Uuc2V0dGluZ3MudmlzaWJpbGl0eS53ZWVrZW5kICYmIGUuc2V0dGluZ3MuaXNvODYwMSA/IDUgPT09IHMgfHwgNiA9PT0gcyA/IGAgJHtlLkNTU0NsYXNzZXMud2Vla0RheVdlZWtlbmR9YCA6IFwiXCIgOiAhZS5zZXR0aW5ncy52aXNpYmlsaXR5LndlZWtlbmQgfHwgZS5zZXR0aW5ncy5pc284NjAxIHx8IDAgIT09IHMgJiYgNiAhPT0gcyA/IFwiXCIgOiBgICR7ZS5DU1NDbGFzc2VzLndlZWtEYXlXZWVrZW5kfWB9YCwgaS5pbm5lclRleHQgPSBgJHtsfWAsIHQuYXBwZW5kQ2hpbGQoaSkgfSB9KShlLCBuLCB0KSkpIH0sIHNlID0gW1wibGlnaHRcIiwgXCJkYXJrXCIsIFwic3lzdGVtXCJdLCBsZSA9IHsgdmFsdWU6ICExLCBzZXQ6ICgpID0+IHsgbGUudmFsdWUgPSAhMCB9LCBjaGVjazogKCkgPT4gbGUudmFsdWUgfSwgaWUgPSAoZSwgdCkgPT4gc2UuZmluZCgobiA9PiB7IHZhciBhOyByZXR1cm4gXCJzeXN0ZW1cIiAhPT0gbiAmJiAobnVsbCA9PSAoYSA9IGUuZ2V0QXR0cmlidXRlKHQpKSA/IHZvaWQgMCA6IGEuaW5jbHVkZXMobikpIH0pKSwgcmUgPSAoZSwgdCkgPT4geyBlLmRhdGFzZXQuY2FsZW5kYXJUaGVtZSA9IHQgfSwgZGUgPSAoZSwgdCkgPT4geyB2YXIgbjsgaWYgKG4gPSB0LCByZShlLkhUTUxFbGVtZW50LCBuLm1hdGNoZXMgPyBcImRhcmtcIiA6IFwibGlnaHRcIiksIFwic3lzdGVtXCIgIT09IGUuc2V0dGluZ3MudmlzaWJpbGl0eS50aGVtZSB8fCBsZS5jaGVjaygpKSByZXR1cm47IGNvbnN0IGEgPSB0ID0+IHsgY29uc3QgbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYC4ke2UuQ1NTQ2xhc3Nlcy5jYWxlbmRhcn1gKTsgbnVsbCA9PSBuIHx8IG4uZm9yRWFjaCgoZSA9PiByZShlLCB0Lm1hdGNoZXMgPyBcImRhcmtcIiA6IFwibGlnaHRcIikpKSB9OyB0LmFkZEV2ZW50TGlzdGVuZXIgPyB0LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgYSkgOiB0LmFkZExpc3RlbmVyKGEpLCBsZS5zZXQoKSB9LCBvZSA9IChlLCB0KSA9PiB7IGNvbnN0IG4gPSBlLnNldHRpbmdzLnZpc2liaWxpdHkudGhlbWVEZXRlY3QgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGUuc2V0dGluZ3MudmlzaWJpbGl0eS50aGVtZURldGVjdCkgOiBudWxsOyBpZiAoIW4pIHJldHVybiB2b2lkIGRlKGUsIHQpOyBjb25zdCBhID0gZS5zZXR0aW5ncy52aXNpYmlsaXR5LnRoZW1lRGV0ZWN0LnJlcGxhY2UoL14uKlxcWyguKylcXF0vZywgKChlLCB0KSA9PiB0KSksIHMgPSBpZShuLCBhKTsgcyA/IChyZShlLkhUTUxFbGVtZW50LCBzKSwgKChlLCB0LCBuKSA9PiB7IG5ldyBNdXRhdGlvbk9ic2VydmVyKChhID0+IHsgZm9yIChsZXQgcyA9IDA7IHMgPCBhLmxlbmd0aDsgcysrKWlmIChhW3NdLmF0dHJpYnV0ZU5hbWUgPT09IG4pIHsgY29uc3QgYSA9IGllKHQsIG4pOyBhICYmIHJlKGUuSFRNTEVsZW1lbnQsIGEpOyBicmVhayB9IH0pKS5vYnNlcnZlKHQsIHsgYXR0cmlidXRlczogITAgfSkgfSkoZSwgbiwgYSkpIDogZGUoZSwgdCkgfSwgY2UgPSBlID0+IHsgY29uc3QgdCA9IHsgZGVmYXVsdDogKCkgPT4geyBhZShlKSwgTihlKSB9LCBtdWx0aXBsZTogKCkgPT4geyBhZShlKSwgTihlKSB9LCBtb250aDogKCkgPT4gRyhlKSwgeWVhcjogKCkgPT4gVyhlKSB9OyAoZSA9PiB7IGlmICghc2UuaW5jbHVkZXMoZS5zZXR0aW5ncy52aXNpYmlsaXR5LnRoZW1lKSkgdGhyb3cgbmV3IEVycm9yKEMpOyBpZiAoXCJub3QgYWxsXCIgPT09IHdpbmRvdy5tYXRjaE1lZGlhKFwiKHByZWZlcnMtY29sb3Itc2NoZW1lKVwiKS5tZWRpYSkgcmV0dXJuIHZvaWQgcmUoZS5IVE1MRWxlbWVudCwgXCJsaWdodFwiKTsgKHsgbGlnaHQ6ICgpID0+IHJlKGUuSFRNTEVsZW1lbnQsIFwibGlnaHRcIiksIGRhcms6ICgpID0+IHJlKGUuSFRNTEVsZW1lbnQsIFwiZGFya1wiKSwgc3lzdGVtOiAoKSA9PiBvZShlLCB3aW5kb3cubWF0Y2hNZWRpYShcIihwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyaylcIikpIH0pW2Uuc2V0dGluZ3MudmlzaWJpbGl0eS50aGVtZV0oKSB9KShlKSwgKGUgPT4geyBpZiAoXCJkZWZpbmVcIiAhPT0gZS5zZXR0aW5ncy5sYW5nIHx8ICFlLmxvY2FsZS53ZWVrZGF5WzZdIHx8ICFlLmxvY2FsZS5tb250aHNbMTFdKSB7IGlmIChcImRlZmluZVwiID09PSBlLnNldHRpbmdzLmxhbmcpIHRocm93IG5ldyBFcnJvcihNKTsgZS5sb2NhbGUud2Vla2RheSA9IFtdLCBlLmxvY2FsZS5tb250aHMgPSBbXTsgZm9yIChsZXQgdCA9IDA7IHQgPCA3OyB0KyspaihlLCB0KTsgZm9yIChsZXQgdCA9IDA7IHQgPCAxMjsgdCsrKUsoZSwgdCkgfSB9KShlKSwgcShlKSwgQShlKSwgRChlKSwgKGUgPT4geyBjb25zdCB0ID0gZS5IVE1MRWxlbWVudC5xdWVyeVNlbGVjdG9yKGAuJHtlLkNTU0NsYXNzZXMudGltZX1gKTsgaWYgKCF0KSByZXR1cm47IGNvbnN0IG4gPSAhMCA9PT0gZS5zZXR0aW5ncy5zZWxlY3Rpb24udGltZSA/IDEyIDogZS5zZXR0aW5ncy5zZWxlY3Rpb24udGltZSwgYSA9IFwicmFuZ2VcIiA9PT0gZS5zZXR0aW5ncy5zZWxlY3Rpb24uY29udHJvbFRpbWUsIFtzLCBsXSA9IFswLCAyM10sIFtpLCByXSA9IFswLCA1OV07IHQuaW5uZXJIVE1MID0gZS5zYW5pdGl6ZXIoYDxkaXYgY2xhc3M9XCIke2UuQ1NTQ2xhc3Nlcy50aW1lQ29udGVudH1cIj4ke3RlKFwiaG91cnNcIiwgZS5DU1NDbGFzc2VzLnRpbWVIb3VycywgZS5zZWxlY3RlZEhvdXJzLCBhKX0ke3RlKFwibWludXRlc1wiLCBlLkNTU0NsYXNzZXMudGltZU1pbnV0ZXMsIGUuc2VsZWN0ZWRNaW51dGVzLCBhKX0kezEyID09PSBuID8gYDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiJHtlLkNTU0NsYXNzZXMudGltZUtlZXBpbmd9XCIke2EgPyBcImRpc2FibGVkXCIgOiBcIlwifT4ke2Uuc2VsZWN0ZWRLZWVwaW5nfTwvYnV0dG9uPmAgOiBcIlwifTwvZGl2PjxkaXYgY2xhc3M9XCIke2UuQ1NTQ2xhc3Nlcy50aW1lUmFuZ2VzfVwiPiR7bmUoXCJob3Vyc1wiLCBlLkNTU0NsYXNzZXMudGltZVJhbmdlLCBzLCBsLCBlLnNldHRpbmdzLnNlbGVjdGlvbi5zdGVwSG91cnMsIGUuc2VsZWN0ZWRLZWVwaW5nID8gWihlLnNlbGVjdGVkSG91cnMsIGUuc2VsZWN0ZWRLZWVwaW5nKSA6IGUuc2VsZWN0ZWRIb3Vycyl9JHtuZShcIm1pbnV0ZXNcIiwgZS5DU1NDbGFzc2VzLnRpbWVSYW5nZSwgaSwgciwgZS5zZXR0aW5ncy5zZWxlY3Rpb24uc3RlcE1pbnV0ZXMsIGUuc2VsZWN0ZWRNaW51dGVzKX08L2Rpdj5gKSwgZWUoZSwgdCwgbikgfSkoZSksIHRbZS5jdXJyZW50VHlwZV0oKSB9LCB1ZSA9IHsgc2VsZjogbnVsbCwgcmFuZ2VNaW46IHZvaWQgMCwgcmFuZ2VNYXg6IHZvaWQgMCB9LCBtZSA9ICgpID0+IHsgdmFyIGU7IGlmICghKG51bGwgPT0gKGUgPSB1ZS5zZWxmKSA/IHZvaWQgMCA6IGUuSFRNTEVsZW1lbnQpKSByZXR1cm47IGNvbnN0IHsgQ1NTQ2xhc3NlczogdCB9ID0gdWUuc2VsZjsgdWUuc2VsZi5IVE1MRWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKGAuJHt1ZS5zZWxmLkNTU0NsYXNzZXMuZGF5QnRuSG92ZXJ9YCkuZm9yRWFjaCgoZSA9PiB7IHZhciBuOyBlLmNsYXNzTGlzdC5yZW1vdmUodWUuc2VsZi5DU1NDbGFzc2VzLmRheUJ0bkhvdmVyKSwgbnVsbCA9PSAobiA9IGUucGFyZW50RWxlbWVudCkgfHwgbi5jbGFzc0xpc3QucmVtb3ZlKHQuZGF5SG92ZXJJbnRlcm1lZGlhdGUsIHQuZGF5SG92ZXJGaXJzdCwgdC5kYXlIb3Zlckxhc3QpIH0pKSB9LCBnZSA9IChlLCB0LCBuKSA9PiB7IHZhciBhLCBzLCBsOyBpZiAoIShudWxsID09IChhID0gdWUuc2VsZikgPyB2b2lkIDAgOiBhLnNlbGVjdGVkRGF0ZXMpKSByZXR1cm47IGNvbnN0IGkgPSBtKGUpLCB7IENTU0NsYXNzZXM6IHIgfSA9IHVlLnNlbGY7IGlmIChudWxsID09IChzID0gdWUuc2VsZi5yYW5nZURpc2FibGVkKSA/IHZvaWQgMCA6IHMuaW5jbHVkZXMoaSkpIHJldHVybjsgY29uc3QgZCA9IG51bGwgPT0gKGwgPSB1ZS5zZWxmLkhUTUxFbGVtZW50KSA/IHZvaWQgMCA6IGwucXVlcnlTZWxlY3RvckFsbChgW2RhdGEtY2FsZW5kYXItZGF5PVwiJHtpfVwiXWApOyBudWxsID09IGQgfHwgZC5mb3JFYWNoKChlID0+IHsgdmFyIHQ7IGUuY2xhc3NMaXN0LmFkZChyLmRheUJ0bkhvdmVyKSwgbnVsbCA9PSAodCA9IGUucGFyZW50RWxlbWVudCkgfHwgdC5jbGFzc0xpc3QuYWRkKHIuZGF5SG92ZXJJbnRlcm1lZGlhdGUpIH0pKSwgbnVsbCA9PSB0IHx8IHQuZm9yRWFjaCgoZSA9PiB7IHZhciB0OyByZXR1cm4gbnVsbCA9PSAodCA9IGUucGFyZW50RWxlbWVudCkgPyB2b2lkIDAgOiB0LmNsYXNzTGlzdC5hZGQoci5kYXlIb3ZlckZpcnN0KSB9KSksIG51bGwgPT0gbiB8fCBuLmZvckVhY2goKGUgPT4geyB2YXIgdDsgcmV0dXJuIG51bGwgPT0gKHQgPSBlLnBhcmVudEVsZW1lbnQpID8gdm9pZCAwIDogdC5jbGFzc0xpc3QuYWRkKHIuZGF5SG92ZXJMYXN0KSB9KSkgfSwgaGUgPSBlID0+IHsgdmFyIHQ7IGlmICghZS50YXJnZXQgfHwgIShudWxsID09ICh0ID0gdWUuc2VsZikgPyB2b2lkIDAgOiB0LnNlbGVjdGVkRGF0ZXMpKSByZXR1cm47IGlmICghZS50YXJnZXQuY2xvc2VzdChgLiR7dWUuc2VsZi5DU1NDbGFzc2VzLmRheXN9YCkpIHJldHVybiB2b2lkIG1lKCk7IGNvbnN0IG4gPSBlLnRhcmdldC5jbG9zZXN0KFwiW2RhdGEtY2FsZW5kYXItZGF5XVwiKTsgaWYgKCFuKSByZXR1cm47IGNvbnN0IGEgPSBuLmRhdGFzZXQuY2FsZW5kYXJEYXksIHMgPSBnKHVlLnNlbGYuc2VsZWN0ZWREYXRlc1swXSksIGwgPSBnKGEpLCBpID0gdWUuc2VsZi5IVE1MRWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKGBbZGF0YS1jYWxlbmRhci1kYXk9XCIke3VlLnNlbGYuc2VsZWN0ZWREYXRlc1swXX1cIl1gKSwgciA9IHVlLnNlbGYuSFRNTEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChgW2RhdGEtY2FsZW5kYXItZGF5PVwiJHthfVwiXWApLCBbZCwgb10gPSBzIDwgbCA/IFtpLCByXSA6IFtyLCBpXSwgW2MsIHVdID0gcyA8IGwgPyBbcywgbF0gOiBbbCwgc107IG1lKCk7IGZvciAobGV0IGUgPSBuZXcgRGF0ZShjKTsgZSA8PSB1OyBlLnNldERhdGUoZS5nZXREYXRlKCkgKyAxKSlnZShlLCBkLCBvKSB9LCB5ZSA9IGUgPT4geyB1ZS5zZWxmICYmIFwiRXNjYXBlXCIgPT09IGUua2V5ICYmICh1ZS5zZWxmLnNlbGVjdGVkRGF0ZXMgPSBbXSwgdWUuc2VsZi5IVE1MRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIGhlKSwgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgeWUpLCBjZSh1ZS5zZWxmKSkgfSwgdmUgPSAoZSwgdCkgPT4geyB2YXIgbjsgaWYgKHQpIHsgY29uc3QgYSA9IDEgPT09IGUuc2VsZWN0ZWREYXRlcy5sZW5ndGggJiYgZS5zZWxlY3RlZERhdGVzWzBdLmluY2x1ZGVzKHQpOyBlLnNlbGVjdGVkRGF0ZXMgPSBhICYmICFlLnNldHRpbmdzLnNlbGVjdGlvbi5jYW5jZWxhYmxlRGF5ID8gW3QsIHRdIDogYSAmJiBlLnNldHRpbmdzLnNlbGVjdGlvbi5jYW5jZWxhYmxlRGF5ID8gW10gOiBlLnNlbGVjdGVkRGF0ZXMubGVuZ3RoID4gMSA/IFt0XSA6IFsuLi5lLnNlbGVjdGVkRGF0ZXMsIHRdLCBudWxsID09IChuID0gZS5zZWxlY3RlZERhdGVzKSB8fCBuLnNvcnQoKChlLCB0KSA9PiArbmV3IERhdGUoZSkgLSArbmV3IERhdGUodCkpKSB9IGUuc2V0dGluZ3MucmFuZ2UuZGlzYWJsZUdhcHMgJiYgKHVlLnJhbmdlTWluID0gdWUucmFuZ2VNaW4gPyB1ZS5yYW5nZU1pbiA6IGUucmFuZ2VNaW4sIHVlLnJhbmdlTWF4ID0gdWUucmFuZ2VNYXggPyB1ZS5yYW5nZU1heCA6IGUucmFuZ2VNYXgpLCB1ZS5zZWxmID0gZTsgY29uc3QgYSA9IHsgc2V0OiAoKSA9PiB7IGUuSFRNTEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBoZSksIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHllKSwgZS5zZXR0aW5ncy5yYW5nZS5kaXNhYmxlR2FwcyAmJiAoKCkgPT4geyB2YXIgZSwgdCwgbjsgaWYgKCEobnVsbCA9PSAodCA9IG51bGwgPT0gKGUgPSB1ZS5zZWxmKSA/IHZvaWQgMCA6IGUuc2VsZWN0ZWREYXRlcykgPyB2b2lkIDAgOiB0WzBdKSB8fCAhKG51bGwgPT0gKG4gPSB1ZS5zZWxmLnJhbmdlRGlzYWJsZWQpID8gdm9pZCAwIDogblswXSkpIHJldHVybjsgY29uc3QgYSA9IGcodWUuc2VsZi5zZWxlY3RlZERhdGVzWzBdKSwgW3MsIGxdID0gdWUuc2VsZi5yYW5nZURpc2FibGVkLm1hcCgoZSA9PiBnKGUpKSkucmVkdWNlKCgoW2UsIHRdLCBuKSA9PiBbYSA+PSBuID8gbiA6IGUsIGEgPCBuICYmIG51bGwgPT09IHQgPyBuIDogdF0pLCBbbnVsbCwgbnVsbF0pOyBzICYmICh1ZS5zZWxmLnJhbmdlTWluID0gbShuZXcgRGF0ZShzLnNldERhdGUocy5nZXREYXRlKCkgKyAxKSkpKSwgbCAmJiAodWUuc2VsZi5yYW5nZU1heCA9IG0obmV3IERhdGUobC5zZXREYXRlKGwuZ2V0RGF0ZSgpIC0gMSkpKSkgfSkoKSB9LCByZXNldDogKCkgPT4geyBjb25zdCBbdCwgbl0gPSBbZS5zZWxlY3RlZERhdGVzWzBdLCBlLnNlbGVjdGVkRGF0ZXNbZS5zZWxlY3RlZERhdGVzLmxlbmd0aCAtIDFdXTsgZS5zZWxlY3RlZERhdGVzID0gZS5zZWxlY3RlZERhdGVzWzBdICE9PSBlLnNlbGVjdGVkRGF0ZXNbZS5zZWxlY3RlZERhdGVzLmxlbmd0aCAtIDFdID8gZS5zZXR0aW5ncy5yYW5nZS5lZGdlc09ubHkgPyBbdCwgbl0gOiBoKFtgJHt0fToke259YF0pIDogW2Uuc2VsZWN0ZWREYXRlc1swXSwgZS5zZWxlY3RlZERhdGVzWzBdXSwgZS5IVE1MRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIGhlKSwgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgeWUpLCBlLnNldHRpbmdzLnJhbmdlLmRpc2FibGVHYXBzICYmIHVlLnNlbGYgJiYgKHVlLnNlbGYucmFuZ2VNaW4gPSB1ZS5yYW5nZU1pbiwgdWUuc2VsZi5yYW5nZU1heCA9IHVlLnJhbmdlTWF4KSB9IH07IGFbMSA9PT0gZS5zZWxlY3RlZERhdGVzLmxlbmd0aCA/IFwic2V0XCIgOiBcInJlc2V0XCJdKCkgfSwgcGUgPSAoZSwgdCwgbikgPT4geyBpZiAoIXQuZGF0YXNldC5jYWxlbmRhckRheSkgcmV0dXJuOyBjb25zdCBhID0gdC5kYXRhc2V0LmNhbGVuZGFyRGF5LCBzID0gdC5jbGFzc0xpc3QuY29udGFpbnMoZS5DU1NDbGFzc2VzLmRheUJ0blNlbGVjdGVkKTsgaWYgKHMgJiYgIWUuc2V0dGluZ3Muc2VsZWN0aW9uLmNhbmNlbGFibGVEYXkpIHJldHVybjsgbGV0IGwgPSAhMDsgdm9pZCAwICE9PSBlLnRvZ2dsZVNlbGVjdGVkICYmIChsID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBlLnRvZ2dsZVNlbGVjdGVkID8gZS50b2dnbGVTZWxlY3RlZChlKSA6IGUudG9nZ2xlU2VsZWN0ZWQpLCBzICYmICFsIHx8IChlLnNlbGVjdGVkRGF0ZXMgPSBzID8gZS5zZWxlY3RlZERhdGVzLmZpbHRlcigoZSA9PiBlICE9PSBhKSkgOiBuID8gWy4uLmUuc2VsZWN0ZWREYXRlcywgYV0gOiBbYV0pIH0sIFNlID0gKGUsIHQsIG4sIGEsIHMpID0+IHsgY29uc3QgbCA9IGUuSFRNTEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChgLiR7ZS5DU1NDbGFzc2VzLmNvbHVtbn1gKSwgaSA9IEFycmF5LmZyb20obCkuZmluZEluZGV4KChlID0+IGUuY2xhc3NMaXN0LmNvbnRhaW5zKHQpKSksIHIgPSBOdW1iZXIobFtpXS5xdWVyeVNlbGVjdG9yKGAuJHtufWApLmdldEF0dHJpYnV0ZShzKSk7IHJldHVybiBcIm1vbnRoXCIgPT09IGUuY3VycmVudFR5cGUgJiYgaSA+PSAwID8gYSAtIGkgOiBcInllYXJcIiA9PT0gZS5jdXJyZW50VHlwZSAmJiBlLnNlbGVjdGVkWWVhciAhPT0gciA/IGEgLSAxIDogYSB9LCBNZSA9IChlLCB0LCBuLCBhKSA9PiB7IGlmICghZS5zZXR0aW5ncy5zZWxlY3Rpb25bbl0pIHJldHVybjsgY29uc3QgcyA9IHQudGFyZ2V0LCBsID0gZSA9PiBzLmNsb3Nlc3QoYC4ke2V9YCksIGkgPSBsKGEuaGVhZGVyKSwgciA9IGwoYS5pdGVtKSwgZCA9IGwoZS5DU1NDbGFzc2VzLmdyaWQpLCBvID0gbChlLkNTU0NsYXNzZXMuY29sdW1uKTsgaWYgKGUuY3VycmVudFR5cGUgIT09IG4gJiYgaSkgeyAoeyB5ZWFyOiAoKSA9PiBXKGUsIHMpLCBtb250aDogKCkgPT4gRyhlLCBzKSB9KVtuXSgpIH0gZWxzZSByID8gKChlLCB0LCBuLCBhLCBzKSA9PiB7IGNvbnN0IGwgPSB7IHllYXI6ICgpID0+IHsgdmFyIG4sIGE7IHJldHVybiBudWxsID09IChhID0gKG4gPSBlLmFjdGlvbnMpLmNsaWNrWWVhcikgPyB2b2lkIDAgOiBhLmNhbGwobiwgdCwgZSkgfSwgbW9udGg6ICgpID0+IHsgdmFyIG4sIGE7IHJldHVybiBudWxsID09IChhID0gKG4gPSBlLmFjdGlvbnMpLmNsaWNrTW9udGgpID8gdm9pZCAwIDogYS5jYWxsKG4sIHQsIGUpIH0gfTsgKHsgeWVhcjogKCkgPT4geyBpZiAoXCJtdWx0aXBsZVwiID09PSBlLnR5cGUpIHsgY29uc3QgdCA9IFNlKGUsIGUuQ1NTQ2xhc3Nlcy5jb2x1bW5ZZWFyLCBlLkNTU0NsYXNzZXMueWVhciwgTnVtYmVyKHMuZGF0YXNldC5jYWxlbmRhclllYXIpLCBcImRhdGEtY2FsZW5kYXItc2VsZWN0ZWQteWVhclwiKSwgbiA9IGUuc2VsZWN0ZWRNb250aCA8IGUuZGF0ZU1pbi5nZXRNb250aCgpICYmIHQgPD0gZS5kYXRlTWluLmdldEZ1bGxZZWFyKCksIGEgPSBlLnNlbGVjdGVkTW9udGggPiBlLmRhdGVNYXguZ2V0TW9udGgoKSAmJiB0ID49IGUuZGF0ZU1heC5nZXRGdWxsWWVhcigpLCBsID0gdCA8IGUuZGF0ZU1pbi5nZXRGdWxsWWVhcigpLCBpID0gdCA+IGUuZGF0ZU1heC5nZXRGdWxsWWVhcigpOyBuIHx8IGwgPyAoZS5zZWxlY3RlZFllYXIgPSBlLmRhdGVNaW4uZ2V0RnVsbFllYXIoKSwgZS5zZWxlY3RlZE1vbnRoID0gZS5kYXRlTWluLmdldE1vbnRoKCkpIDogYSB8fCBpID8gKGUuc2VsZWN0ZWRZZWFyID0gZS5kYXRlTWF4LmdldEZ1bGxZZWFyKCksIGUuc2VsZWN0ZWRNb250aCA9IGUuZGF0ZU1heC5nZXRNb250aCgpKSA6IGUuc2VsZWN0ZWRZZWFyID0gdCB9IGVsc2UgZS5zZWxlY3RlZFllYXIgPSBOdW1iZXIocy5kYXRhc2V0LmNhbGVuZGFyWWVhcikgfSwgbW9udGg6ICgpID0+IHsgaWYgKFwibXVsdGlwbGVcIiA9PT0gZS50eXBlKSB7IGNvbnN0IHQgPSBTZShlLCBlLkNTU0NsYXNzZXMuY29sdW1uTW9udGgsIGUuQ1NTQ2xhc3Nlcy5tb250aCwgTnVtYmVyKHMuZGF0YXNldC5jYWxlbmRhck1vbnRoKSwgXCJkYXRhLWNhbGVuZGFyLXNlbGVjdGVkLW1vbnRoXCIpLCBuID0gcy5jbG9zZXN0KGAuJHthLmNvbHVtbn1gKS5xdWVyeVNlbGVjdG9yKGAuJHtlLkNTU0NsYXNzZXMueWVhcn1gKTsgZS5zZWxlY3RlZFllYXIgPSBOdW1iZXIobi5kYXRhc2V0LmNhbGVuZGFyU2VsZWN0ZWRZZWFyKTsgY29uc3QgbCA9IHQgPCBlLmRhdGVNaW4uZ2V0TW9udGgoKSAmJiBlLnNlbGVjdGVkWWVhciA8PSBlLmRhdGVNaW4uZ2V0RnVsbFllYXIoKSwgaSA9IHQgPiBlLmRhdGVNYXguZ2V0TW9udGgoKSAmJiBlLnNlbGVjdGVkWWVhciA+PSBlLmRhdGVNYXguZ2V0RnVsbFllYXIoKTsgZS5zZWxlY3RlZE1vbnRoID0gbCA/IGUuZGF0ZU1pbi5nZXRNb250aCgpIDogaSA/IGUuZGF0ZU1heC5nZXRNb250aCgpIDogdCB9IGVsc2UgZS5zZWxlY3RlZE1vbnRoID0gTnVtYmVyKHMuZGF0YXNldC5jYWxlbmRhck1vbnRoKSB9IH0pW25dKCksIGxbbl0oKSwgZS5jdXJyZW50VHlwZSA9IGUudHlwZSwgY2UoZSkgfSkoZSwgdCwgbiwgYSwgcikgOiAoZS5jdXJyZW50VHlwZSA9PT0gbiAmJiBpIHx8IFwibXVsdGlwbGVcIiA9PT0gZS50eXBlICYmIGUuY3VycmVudFR5cGUgPT09IG4gJiYgZCAmJiAhbykgJiYgKGUuY3VycmVudFR5cGUgPSBlLnR5cGUsIGNlKGUpKSB9LCBDZSA9IGUgPT4geyBjb25zdCB0ID0gdCA9PiB7ICgoZSwgdCkgPT4geyBjb25zdCBuID0gdC50YXJnZXQuY2xvc2VzdChgLiR7ZS5DU1NDbGFzc2VzLmFycm93fWApOyBuICYmIChbXCJkZWZhdWx0XCIsIFwibXVsdGlwbGVcIl0uaW5jbHVkZXMoZS5jdXJyZW50VHlwZSkgPyBJKGUsIG4uZGF0YXNldC5jYWxlbmRhckFycm93KSA6IFwieWVhclwiID09PSBlLmN1cnJlbnRUeXBlICYmIHZvaWQgMCAhPT0gZS52aWV3WWVhciAmJiAoZS52aWV3WWVhciArPSB7IHByZXY6IC0xNSwgbmV4dDogMTUgfVtuLmRhdGFzZXQuY2FsZW5kYXJBcnJvd10sIFcoZSwgdC50YXJnZXQpKSwgZS5hY3Rpb25zLmNsaWNrQXJyb3cgJiYgZS5hY3Rpb25zLmNsaWNrQXJyb3codCwgZSkpIH0pKGUsIHQpLCAoKGUsIHQpID0+IHsgdmFyIG47IGlmICghZS5zZXR0aW5ncy52aXNpYmlsaXR5LndlZWtOdW1iZXJzIHx8ICFlLmFjdGlvbnMuY2xpY2tXZWVrTnVtYmVyKSByZXR1cm47IGNvbnN0IGEgPSB0LnRhcmdldC5jbG9zZXN0KGAuJHtlLkNTU0NsYXNzZXMud2Vla051bWJlcn1gKSwgcyA9IG51bGwgPT0gKG4gPSBlLkhUTUxFbGVtZW50KSA/IHZvaWQgMCA6IG4ucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLWNhbGVuZGFyLXdlZWstbnVtYmVyXVwiKTsgaWYgKCFhIHx8ICFzKSByZXR1cm47IGNvbnN0IGwgPSBOdW1iZXIoYS5pbm5lclRleHQpLCBpID0gTnVtYmVyKGEuZGF0YXNldC5jYWxlbmRhclllYXJXZWVrKSwgciA9IEFycmF5LmZyb20ocykuZmlsdGVyKChlID0+IE51bWJlcihlLmRhdGFzZXQuY2FsZW5kYXJXZWVrTnVtYmVyKSA9PT0gbCkpOyBlLmFjdGlvbnMuY2xpY2tXZWVrTnVtYmVyKHQsIGwsIHIsIGksIGUpIH0pKGUsIHQpLCAoKGUsIHQpID0+IHsgdmFyIG47IGNvbnN0IGEgPSB0LnRhcmdldCwgcyA9IGUgPT4gYS5jbG9zZXN0KGAuJHtlfWApLCBsID0gcyhlLkNTU0NsYXNzZXMuZGF5QnRuKTsgaWYgKCFlLnNldHRpbmdzLnNlbGVjdGlvbi5kYXkgfHwgIVtcInNpbmdsZVwiLCBcIm11bHRpcGxlXCIsIFwibXVsdGlwbGUtcmFuZ2VkXCJdLmluY2x1ZGVzKGUuc2V0dGluZ3Muc2VsZWN0aW9uLmRheSkgfHwgIWwpIHJldHVybjsgKHsgc2luZ2xlOiAoKSA9PiBwZShlLCBsLCAhMSksIG11bHRpcGxlOiAoKSA9PiBwZShlLCBsLCAhMCksIFwibXVsdGlwbGUtcmFuZ2VkXCI6ICgpID0+IHZlKGUsIGwuZGF0YXNldC5jYWxlbmRhckRheSkgfSlbZS5zZXR0aW5ncy5zZWxlY3Rpb24uZGF5XSgpLCBudWxsID09IChuID0gZS5zZWxlY3RlZERhdGVzKSB8fCBuLnNvcnQoKChlLCB0KSA9PiArbmV3IERhdGUoZSkgLSArbmV3IERhdGUodCkpKSwgZS5hY3Rpb25zLmNsaWNrRGF5ICYmIGUuYWN0aW9ucy5jbGlja0RheSh0LCBlKSwgZS5pbnB1dCAmJiBlLkhUTUxJbnB1dEVsZW1lbnQgJiYgZS5IVE1MRWxlbWVudCAmJiBlLmFjdGlvbnMuY2hhbmdlVG9JbnB1dCAmJiBlLmFjdGlvbnMuY2hhbmdlVG9JbnB1dCh0LCBlKTsgY29uc3QgaSA9IHMoZS5DU1NDbGFzc2VzLmRheUJ0blByZXYpLCByID0gcyhlLkNTU0NsYXNzZXMuZGF5QnRuTmV4dCk7ICh7IHByZXY6ICgpID0+IEkoZSwgXCJwcmV2XCIpLCBuZXh0OiAoKSA9PiBJKGUsIFwibmV4dFwiKSwgZGVmYXVsdDogKCkgPT4gTihlKSB9KVtpID8gXCJwcmV2XCIgOiByID8gXCJuZXh0XCIgOiBcImRlZmF1bHRcIl0oKSB9KShlLCB0KSwgTWUoZSwgdCwgXCJtb250aFwiLCB7IGhlYWRlcjogZS5DU1NDbGFzc2VzLm1vbnRoLCBpdGVtOiBlLkNTU0NsYXNzZXMubW9udGhzTW9udGgsIGNvbHVtbjogZS5DU1NDbGFzc2VzLmNvbHVtbk1vbnRoIH0pLCBNZShlLCB0LCBcInllYXJcIiwgeyBoZWFkZXI6IGUuQ1NTQ2xhc3Nlcy55ZWFyLCBpdGVtOiBlLkNTU0NsYXNzZXMueWVhcnNZZWFyLCBjb2x1bW46IGUuQ1NTQ2xhc3Nlcy5jb2x1bW5ZZWFyIH0pIH07IHJldHVybiBlLkhUTUxFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0KSwgKCkgPT4gZS5IVE1MRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdCkgfSwgYmUgPSAoZSwgeyB5ZWFyOiB0LCBtb250aDogbiwgZGF0ZXM6IGEsIGhvbGlkYXlzOiBzLCB0aW1lOiBpIH0gPSB7fSkgPT4geyB2YXIgcjsgY29uc3QgZCA9IGwoe30sIGUuc2V0dGluZ3Muc2VsZWN0ZWQpOyBlLnNldHRpbmdzLnNlbGVjdGVkLnllYXIgPSB0ID8gZC55ZWFyIDogZS5zZWxlY3RlZFllYXIsIGUuc2V0dGluZ3Muc2VsZWN0ZWQubW9udGggPSBuID8gZC5tb250aCA6IGUuc2VsZWN0ZWRNb250aCwgZS5zZXR0aW5ncy5zZWxlY3RlZC5ob2xpZGF5cyA9IHMgPyBkLmhvbGlkYXlzIDogZS5zZWxlY3RlZEhvbGlkYXlzLCBlLnNldHRpbmdzLnNlbGVjdGVkLnRpbWUgPSBpID8gZC50aW1lIDogZS5zZWxlY3RlZFRpbWUsIGUuc2V0dGluZ3Muc2VsZWN0ZWQuZGF0ZXMgPSBcIm9ubHktZmlyc3RcIiA9PT0gYSAmJiAobnVsbCA9PSAociA9IGUuc2VsZWN0ZWREYXRlcykgPyB2b2lkIDAgOiByWzBdKSA/IFtlLnNlbGVjdGVkRGF0ZXNbMF1dIDogITAgPT09IGEgPyBkLmRhdGVzIDogZS5zZWxlY3RlZERhdGVzLCBmKGUpLCBjZShlKSwgZS5zZXR0aW5ncy5zZWxlY3RlZCA9IGQsIFwibXVsdGlwbGUtcmFuZ2VkXCIgPT09IGUuc2V0dGluZ3Muc2VsZWN0aW9uLmRheSAmJiBhICYmIHZlKGUpIH0sIGZlID0gKGUsIHQgPSAhMCkgPT4geyBlLmlzSW5wdXRJbml0ID0gITA7IGNvbnN0IG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpOyByZXR1cm4gbi5jbGFzc05hbWUgPSBgJHtlLkNTU0NsYXNzZXMuY2FsZW5kYXJ9ICR7ZS5DU1NDbGFzc2VzLmNhbGVuZGFyVG9JbnB1dH0gJHtlLkNTU0NsYXNzZXMuY2FsZW5kYXJIaWRkZW59YCwgZS5IVE1MRWxlbWVudCA9IG4sIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZS5IVE1MRWxlbWVudCksIGUuSFRNTEVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCIsIHQgJiYgcXVldWVNaWNyb3Rhc2soKCgpID0+IHsgayhlLkhUTUxJbnB1dEVsZW1lbnQsIG4sIGUuc2V0dGluZ3MudmlzaWJpbGl0eS5wb3NpdGlvblRvSW5wdXQsIGUuQ1NTQ2xhc3NlcyksIGUuSFRNTEVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9IFwidmlzaWJsZVwiLCBlLnNob3coKSB9KSksIGJlKGUsIHsgeWVhcjogITAsIG1vbnRoOiAhMCwgZGF0ZXM6ICEwLCBob2xpZGF5czogITAsIHRpbWU6ICEwIH0pLCBlLmFjdGlvbnMuaW5pdENhbGVuZGFyICYmIGUuYWN0aW9ucy5pbml0Q2FsZW5kYXIoZSksIENlKGUpIH0sIHdlID0gZSA9PiAoZS5IVE1MT3JpZ2luYWxFbGVtZW50ID0gZS5IVE1MRWxlbWVudC5jbG9uZU5vZGUoITApLCBlLmlzSW5pdCA9ICEwLCBlLmlucHV0ID8gKGUgPT4geyBjb25zdCB0ID0gW107IGUuSFRNTElucHV0RWxlbWVudCA9IGUuSFRNTEVsZW1lbnQ7IGNvbnN0IG4gPSAoKSA9PiBrKGUuSFRNTElucHV0RWxlbWVudCwgZS5IVE1MRWxlbWVudCwgZS5zZXR0aW5ncy52aXNpYmlsaXR5LnBvc2l0aW9uVG9JbnB1dCwgZS5DU1NDbGFzc2VzKSwgYSA9IHQgPT4geyBcIkVzY2FwZVwiID09PSB0LmtleSAmJiAoKG51bGwgPT0gZSA/IHZvaWQgMCA6IGUuSFRNTElucHV0RWxlbWVudCkgJiYgKG51bGwgPT0gZSA/IHZvaWQgMCA6IGUuSFRNTEVsZW1lbnQpICYmIGUuaGlkZSgpLCBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBhKSkgfSwgcyA9IHQgPT4geyB2YXIgYTsgZSAmJiB0LnRhcmdldCAhPT0gZS5IVE1MSW5wdXRFbGVtZW50ICYmICEobnVsbCA9PSAoYSA9IGUuSFRNTEVsZW1lbnQpID8gdm9pZCAwIDogYS5jb250YWlucyh0LnRhcmdldCkpICYmIChlLkhUTUxJbnB1dEVsZW1lbnQgJiYgZS5IVE1MRWxlbWVudCAmJiBlLmhpZGUoKSwgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgbiksIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBzLCB7IGNhcHR1cmU6ICEwIH0pKSB9LCBsID0gKCkgPT4geyBlLmlzSW5wdXRJbml0ID8gKGsoZS5IVE1MSW5wdXRFbGVtZW50LCBlLkhUTUxFbGVtZW50LCBlLnNldHRpbmdzLnZpc2liaWxpdHkucG9zaXRpb25Ub0lucHV0LCBlLkNTU0NsYXNzZXMpLCBlLkhUTUxFbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPSBcInZpc2libGVcIiwgZS5zaG93KCkpIDogdC5wdXNoKGZlKGUpKSwgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgbiksIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBzLCB7IGNhcHR1cmU6ICEwIH0pLCBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBhKSB9OyByZXR1cm4gZS5IVE1MSW5wdXRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBsKSwgZS5IVE1MSW5wdXRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCBsKSwgKCkgPT4geyB0LmZvckVhY2goKGUgPT4gZSgpKSkgfSB9KShlKSA6IChmKGUpLCBjZShlKSwgZS5hY3Rpb25zLmluaXRDYWxlbmRhciAmJiBlLmFjdGlvbnMuaW5pdENhbGVuZGFyKGUpLCBDZShlKSkpOyByZXR1cm4gY2xhc3MgZXh0ZW5kcyB1IHsgY29uc3RydWN0b3IoZSwgdCkgeyBpZiAoc3VwZXIoKSwgaSh0aGlzLCBcImluaXRcIiwgKCgpID0+IHdlKHRoaXMpKSksIGkodGhpcywgXCJ1cGRhdGVcIiwgKGUgPT4gKChlLCB7IHllYXI6IHQsIG1vbnRoOiBuLCBkYXRlczogYSwgaG9saWRheXM6IHMsIHRpbWU6IGwgfSA9IHt9KSA9PiB7IGlmICghZS5pc0luaXQpIHRocm93IG5ldyBFcnJvcihTKTsgZS5pbnB1dCAmJiAhZS5pc0lucHV0SW5pdCAmJiBmZShlLCAhMSksIGJlKGUsIHsgeWVhcjogdCwgbW9udGg6IG4sIGRhdGVzOiBhLCBob2xpZGF5czogcywgdGltZTogbCB9KSwgZS5hY3Rpb25zLnVwZGF0ZUNhbGVuZGFyICYmIGUuYWN0aW9ucy51cGRhdGVDYWxlbmRhcihlKSB9KSh0aGlzLCBlKSkpLCBpKHRoaXMsIFwiZGVzdHJveVwiLCAoKCkgPT4gKGUgPT4geyB2YXIgdCwgbiwgYSwgcywgbCwgaTsgaWYgKCFlLmlzSW5pdCkgdGhyb3cgbmV3IEVycm9yKFMpOyBlLmlucHV0ID8gKG51bGwgPT0gKG4gPSBudWxsID09ICh0ID0gZS5IVE1MRWxlbWVudCkgPyB2b2lkIDAgOiB0LnBhcmVudEVsZW1lbnQpIHx8IG4ucmVtb3ZlQ2hpbGQoZS5IVE1MRWxlbWVudCksIG51bGwgPT0gKHMgPSBudWxsID09IChhID0gZS5IVE1MSW5wdXRFbGVtZW50KSA/IHZvaWQgMCA6IGEucmVwbGFjZVdpdGgpIHx8IHMuY2FsbChhLCBlLkhUTUxPcmlnaW5hbEVsZW1lbnQpLCBlLkhUTUxJbnB1dEVsZW1lbnQgPSB2b2lkIDApIDogbnVsbCA9PSAoaSA9IG51bGwgPT0gKGwgPSBlLkhUTUxFbGVtZW50KSA/IHZvaWQgMCA6IGwucmVwbGFjZVdpdGgpIHx8IGkuY2FsbChsLCBlLkhUTUxPcmlnaW5hbEVsZW1lbnQpLCBlLkhUTUxFbGVtZW50ID0gZS5IVE1MT3JpZ2luYWxFbGVtZW50LCBlLmFjdGlvbnMuZGVzdHJveUNhbGVuZGFyICYmIGUuYWN0aW9ucy5kZXN0cm95Q2FsZW5kYXIoZSkgfSkodGhpcykpKSwgaSh0aGlzLCBcInNob3dcIiwgKCgpID0+IHsgdmFyIGU7IChlID0gdGhpcykuY3VycmVudFR5cGUgPyAoZS5IVE1MRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGUuQ1NTQ2xhc3Nlcy5jYWxlbmRhckhpZGRlbiksIGUuYWN0aW9ucy5zaG93Q2FsZW5kYXIgJiYgZS5hY3Rpb25zLnNob3dDYWxlbmRhcihlKSkgOiBlLkhUTUxFbGVtZW50LmNsaWNrKCkgfSkpLCBpKHRoaXMsIFwiaGlkZVwiLCAoKCkgPT4geyB2YXIgZTsgKGUgPSB0aGlzKS5jdXJyZW50VHlwZSAmJiAoZS5IVE1MRWxlbWVudC5jbGFzc0xpc3QuYWRkKGUuQ1NTQ2xhc3Nlcy5jYWxlbmRhckhpZGRlbiksIGUuYWN0aW9ucy5oaWRlQ2FsZW5kYXIgJiYgZS5hY3Rpb25zLmhpZGVDYWxlbmRhcihlKSkgfSkpLCB0aGlzLkhUTUxFbGVtZW50ID0gXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZSkgOiBlLCAhdGhpcy5IVE1MRWxlbWVudCkgdGhyb3cgbmV3IEVycm9yKHAoZSkpOyBpZiAoIXQpIHJldHVybjsgY29uc3QgbiA9IChlLCB0KSA9PiB7IE9iamVjdC5rZXlzKHQpLmZvckVhY2goKGEgPT4geyBcIm9iamVjdFwiICE9IHR5cGVvZiBlW2FdIHx8IFwib2JqZWN0XCIgIT0gdHlwZW9mIHRbYV0gfHwgdFthXSBpbnN0YW5jZW9mIERhdGUgPyBlW2FdID0gdFthXSA6IG4oZVthXSwgdFthXSkgfSkpIH07IG4odGhpcywgdCkgfSB9IH0pKTtcbiJdLCJmaWxlIjoiY2FsZW5kYXIvdmFuaWxsYS1jYWxlbmRhci5taW4uanMifQ==
